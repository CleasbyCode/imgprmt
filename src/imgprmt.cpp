//  imgprmt v1.3 (Linux / Windows CLI Edition). Created by Nicholas Cleasby (@CleasbyCode) 19/05/2023

// Compile program (Linux):

// $ sudo apt-get install libturbojpeg0-dev

// $ chmod +x compile_imgprmt.sh
// $ ./compile_imgprmt.sh
	
// $ Compilation successful. Executable 'imgprmt' created.
// $ sudo cp imgprmt /usr/bin
// $ imgprmt

#ifdef _WIN32
	#define NOMINMAX
    #include <windows.h>

    #include "windows/libjpeg-turbo/include/turbojpeg.h"
    // This software is based in part on the work of the Independent JPEG Group.
	// Copyright (C) 2009-2024 D. R. Commander. All Rights Reserved.
	// Copyright (C) 2015 Viktor Szathmáry. All Rights Reserved.
	// https://github.com/libjpeg-turbo/libjpeg-turbo
    	
   	#include <fcntl.h>
    #include <io.h>
    #include <cstdio>
#else
	#include <clocale> 
  	#include <locale>   
    #include <cwchar>
    #include <termios.h>
	#include <unistd.h>
    #include <turbojpeg.h>
#endif

#include <string>
#include <string_view>
#include <cstring>
#include <cctype>
#include <cstddef>
#include <cstdlib>
#include <cstdint>
#include <initializer_list>
#include <optional>
#include <span>
#include <stdexcept>
#include <iostream>
#include <fstream>
#include <array>
#include <vector>
#include <filesystem>
#include <algorithm>
#include <random>

namespace fs = std::filesystem;

using Byte   = std::uint8_t;
using vBytes = std::vector<Byte>;

static void display_info() {
	std::cout << R"(
Imgprmt v1.3 (CLI Edition).
Created by Nicholas Cleasby (@CleasbyCode) 25/05/2023.

imgprmt is a command-line tool for Linux and Windows that
embeds image text prompts into JPG images. 
		
It outputs a unique JPG-HTML polyglot file, combining image, prompt text & html.

Share the resulting image on compatible social media platforms like:-
		
X-Twitter, Tumblr, Mastodon, Pixelfed, Flickr & *Bluesky.
		
The embedded prompt is preserved for anyone who downloads the image.

To view the stored prompt locally, rename the image extension to ".htm" and open
it in a web browser to display the basic webpage.

For a convenient alternative to downloading & compiling the CLI source code, use the imgprmt Web App:-
		
https://cleasbycode.co.uk/imgprmt/app/
________________________
Compile & run (Linux)
________________________
		
  $ sudo apt-get install libturbojpeg0-dev

  $ chmod +x compile_imgprmt.sh
  $ ./compile_imgprmt.sh

  Compilation successful. Executable 'imgprmt' created.

  $ sudo cp imgprmt /usr/bin
  $ imgprmt
________________________
Usage
________________________

  imgprmt [-b] <jpg_image>
  imgprmt --info

With the default command-line arguments without any option(s), 
the embedded image can be posted on X-Twitter, Tumblr, Mastodon Pixelfed & Flickr.
		
The default prompt limit is 57140 bytes (minus URL address length).
		
X-Twitter, for compatibility reasons, is limited to 1845 bytes (minus URL address length).
Considerably smaller than the default size, but should be adequate for most prompts.

If you intend to share your prompt-embedded image on Bluesky,
you must first add the -b option to the command-line arguments:-

$ imgprmt -b my_image.jpg

Secondly, to post the image on Bluesky, you will need to use the bsky_post.py script, 
located in the repo src folder.

To run this script, you need Python3 and the 'requests' and 'bs4' (BeautifulSoup)
Python packages installed.

An app-password is also required for the Python script, which you can create 
from your Bluesky account: https://bsky.app/settings/app-passwords

Here are some basic usage examples for the bsky_post.py Python script:

Standard image post to your profile/account.

$ python3 bsky_post.py --handle you.bsky.social --password xxxx-xxxx-xxxx-xxxx 
--image your_image.jpg --alt-text "alt-text here [optional]" "standard post text here [required]"

If you want to post multiple images (Max. 4):

$ python3 bsky_post.py --handle you.bsky.social --password xxxx-xxxx-xxxx-xxxx 
--image img1.jpg --image img2.jpg --alt-text "alt_here" "standard post text..."

If you want to post an image as a reply to another thread:

$ python3 bsky_post.py --handle you.bsky.social --password xxxx-xxxx-xxxx-xxxx 
--image your_image.jpg --alt-text "alt_here" 
--reply-to https://bsky.app/profile/someone.bsky.social/post/8m2tgw6cgi23i 
"standard post text..."

Images created with the -b option can also be posted on Tumblr (bsky_post.py script not required). 
Image file size upload limit for Bluesky is ~1MB.

)";
}

enum class Option : Byte { None, Bluesky };

struct program_args {
    Option option{Option::None};
    fs::path image_file_path;

    static std::optional<program_args> parse(int argc, char** argv) {
    	using std::string_view;

        auto arg = [&](int i) -> string_view {
            return (i >= 0 && i < argc) ? string_view(argv[i]) : string_view{};
        };

        const std::string
        	PROG  = fs::path(argv[0]).filename().string(),
        	USAGE = "Usage: " + PROG + " [-b] <jpg_image>\n\t\b" + PROG + " --info";

        auto die = [&]() -> void { throw std::runtime_error(USAGE); };

        if (argc < 2 || argc > 3) die();

        if (argc == 2 && arg(1) == "--info") {
            display_info();
            return std::nullopt;  
        }

        program_args out{};
        int i = 1;

        if (arg(i) == "-b") {
            out.option = Option::Bluesky;
            ++i;
        }

        out.image_file_path = fs::path(arg(i));
        return out;
    }
};

// Default limit of 0 means "Search Whole File". 
// Any other value means "Search ONLY up to this limit".
static std::optional<std::size_t> searchSig(const vBytes& v, std::span<const Byte> sig, std::size_t limit = 0) {   
	auto end_it = (limit == 0 || limit > v.size()) 
    	? v.end() 
    	: v.begin() + limit;

    auto it = std::search(v.begin(), end_it, sig.begin(), sig.end());
    
    if (it == end_it) return std::nullopt;
    return static_cast<std::size_t>(it - v.begin());
}

// Writes updated values (2, 4 or 8 bytes), such as segments lengths, index/offsets values, PIN, etc. into the relevant vector index location.	
static void updateValue(vBytes& vec, std::size_t index, std::size_t value, Byte bits) {
    // Allow only 16, 32, or 64 bits.
    if (bits != 16 && bits != 32 && bits != 64) {
        throw std::invalid_argument("updateValue: Invalid bit length. Must be 16, 32, or 64.");
    }

    std::size_t bytes_needed = bits / 8;
    
    if (index + bytes_needed > vec.size()) {
        throw std::out_of_range("updateValue: Index out of bounds.");
    }

    // Write new value to vector index location (Big Endian).
    while (bits > 0) {
        bits -= 8;
        vec[index++] = static_cast<Byte>((value >> bits) & 0xFF);
    }
}

[[nodiscard]] static std::optional<uint16_t> exifOrientation(const vBytes& jpg) {
	constexpr size_t EXIF_SEARCH_LIMIT = 4096ULL;
	constexpr auto APP1_SIG = std::to_array<Byte>({0xFF, 0xE1});

	auto app1_pos_opt = searchSig(jpg, std::span<const Byte>(APP1_SIG), EXIF_SEARCH_LIMIT);

    if (!app1_pos_opt) return std::nullopt;
    std::size_t pos = *app1_pos_opt;

    if (pos + 4 > jpg.size()) return std::nullopt;

    uint16_t segment_length = (static_cast<uint16_t>(jpg[pos + 2]) << 8) | jpg[pos + 3];
    std::size_t exif_end = pos + 2 + segment_length;

    if (exif_end > jpg.size()) return std::nullopt;

    std::span<const Byte> payload(jpg.data() + pos + 4, segment_length - 2);

    constexpr std::size_t EXIF_HEADER_SIZE = 6ULL;
    constexpr auto EXIF_SIG = std::to_array<Byte>({'E', 'x', 'i', 'f', '\0', '\0'});

    if (payload.size() < EXIF_HEADER_SIZE || 
    	std::memcmp(payload.data(), EXIF_SIG.data(), EXIF_HEADER_SIZE) != 0) {
        return std::nullopt;
    }
    
    std::span<const Byte> tiff_data = payload.subspan(EXIF_HEADER_SIZE);
    
    if (tiff_data.size() < 8) return std::nullopt; 

    bool is_le = false;
    if (tiff_data[0] == 'I' && tiff_data[1] == 'I') is_le = true;      
    else if (tiff_data[0] == 'M' && tiff_data[1] == 'M') is_le = false;
    else return std::nullopt;

    auto read16 = [&](std::size_t offset) -> uint16_t {
    	if (offset + 2 > tiff_data.size()) return 0;
        return is_le ? 
            static_cast<uint16_t>(tiff_data[offset] | (tiff_data[offset + 1] << 8)) :
            static_cast<uint16_t>((tiff_data[offset] << 8) | tiff_data[offset + 1]);
    };

    auto read32 = [&](std::size_t offset) -> uint32_t {
        if (offset + 4 > tiff_data.size()) return 0;
        if (is_le) {
            return static_cast<uint32_t>(tiff_data[offset]) | 
                   (static_cast<uint32_t>(tiff_data[offset + 1]) << 8) | 
                   (static_cast<uint32_t>(tiff_data[offset + 2]) << 16) | 
                   (static_cast<uint32_t>(tiff_data[offset + 3]) << 24);
        } else {
            return (static_cast<uint32_t>(tiff_data[offset]) << 24) | 
                   (static_cast<uint32_t>(tiff_data[offset + 1]) << 16) | 
                   (static_cast<uint32_t>(tiff_data[offset + 2]) << 8) | 
                   static_cast<uint32_t>(tiff_data[offset + 3]);
        }
    };

    if (read16(2) != 0x002A) return std::nullopt;

    uint32_t ifd_offset = read32(4);
    
    if (ifd_offset < 8 || ifd_offset >= tiff_data.size()) return std::nullopt;
    
    uint16_t entry_count = read16(ifd_offset);
    std::size_t current_entry = ifd_offset + 2; 

    constexpr uint16_t TAG_ORIENTATION = 0x0112;
    constexpr std::size_t ENTRY_SIZE = 12ULL;

    for (uint16_t i = 0; i < entry_count; ++i) {
    	if (current_entry + ENTRY_SIZE > tiff_data.size()) return std::nullopt;

        uint16_t tag_id = read16(current_entry);
        
        if (tag_id == TAG_ORIENTATION) {
            return read16(current_entry + 8);
        }
        current_entry += ENTRY_SIZE;
    }
    return std::nullopt;
}

// Helper: Map EXIF orientation (1-8) to TurboJPEG Transform Operations
static int getTransformOp(uint16_t orientation) {
    switch (orientation) {
        case 2: return TJXOP_HFLIP;
        case 3: return TJXOP_ROT180;
        case 4: return TJXOP_VFLIP;
        case 5: return TJXOP_TRANSPOSE;
        case 6: return TJXOP_ROT90;
        case 7: return TJXOP_TRANSVERSE;
        case 8: return TJXOP_ROT270;
        default: return TJXOP_NONE;
    }
}

// TurboJPEG. RAII wrapper for tjhandle (decompressor or compressor)
struct TJHandle {
	tjhandle handle = nullptr;

    TJHandle() = default;

    TJHandle(const TJHandle&) = delete;
   	TJHandle& operator=(const TJHandle&) = delete;

    TJHandle(TJHandle&& other) noexcept : handle(other.handle) {
        other.handle = nullptr;
    }
    
    TJHandle& operator=(TJHandle&& other) noexcept {
    	if (this != &other) {
        	reset();
            handle = other.handle;
            other.handle = nullptr;
        }
        return *this;
    }

    ~TJHandle() {
        reset();
    }

    void reset() {
        if (handle) {
        	tjDestroy(handle);
            handle = nullptr;
        }
    }

    tjhandle get() const { return handle; }
    tjhandle operator->() const { return handle; }
    explicit operator bool() const { return handle != nullptr; }
};

struct TJBuffer {
	unsigned char* data = nullptr;
	~TJBuffer() { if (data) tjFree(data); }
};

// Standard JPEG Luminance Quantization Table (Quality 50) in ZigZag order
static constexpr auto STD_LUMA_QTABLE = std::to_array<Byte>({
	16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40, 
    26, 24, 22, 22, 24, 49, 35, 37, 29, 40, 58, 51, 61, 60, 57, 51, 
    56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55, 56, 80, 109, 81, 87, 
    95, 98, 103, 104, 103, 62, 77, 113, 121, 112, 100, 120, 92, 101, 103, 99
});

static int estimateImageQuality(const vBytes& jpg) {
	constexpr auto DQT_SIG = std::to_array<Byte>({0xFF, 0xDB});
    
    constexpr size_t DQT_SEARCH_LIMIT = 32768ULL;

    auto dqt_pos_opt = searchSig(jpg, std::span<const Byte>(DQT_SIG), DQT_SEARCH_LIMIT);
    if (!dqt_pos_opt) return 80; 

    std::size_t pos = *dqt_pos_opt;

    if (pos + 4 > jpg.size()) return 80;

    std::size_t 
		length = (static_cast<std::size_t>(jpg[pos + 2]) << 8) | jpg[pos + 3],
    	end    = pos + 2 + length;
    
    if (end > jpg.size()) return 80;

    pos += 4; 

    while (pos < end) {
    	if (pos + 65 > end) break; 
        Byte 
			header 	  = jpg[pos++],
        	precision = (header >> 4) & 0x0F,
        	table_id  = header & 0x0F;
		
        if (precision == 0 && table_id == 0) {
            double total_scale = 0.0;
            
            for (size_t i = 0; i < 64; ++i) {
				double 
					val = static_cast<double>(jpg[pos + i]),
                	std = static_cast<double>(STD_LUMA_QTABLE[i]);
				
                total_scale += (val * 100.0) / std;
            }
        
            total_scale /= 64.0;

            if (total_scale <= 0.0) return 100;
            
            if (total_scale <= 100.0) {
            	return static_cast<int>(200.0 - total_scale) / 2;
            } else {
            	return static_cast<int>(5000.0 / total_scale);
            }
        }   
        pos += 64; 
    }
    return 80; 
}

static void optimizeImage(vBytes& jpg_vec) {
	if (jpg_vec.empty()) {
        throw std::runtime_error("JPG image is empty!");
    }

    TJHandle transformer;
    transformer.handle = tjInitTransform();
    if (!transformer.handle) {
        throw std::runtime_error("tjInitTransform() failed");
    }
  
    int width = 0, height = 0, jpegSubsamp = 0, jpegColorspace = 0;
    if (tjDecompressHeader3(transformer.get(), jpg_vec.data(), static_cast<unsigned long>(jpg_vec.size()), &width, &height, &jpegSubsamp, &jpegColorspace) != 0) {
        throw std::runtime_error(std::string("Image Error: ") + tjGetErrorStr2(transformer.get()));
    }

	if (width < 300 && height < 300) {
        throw std::runtime_error("Image Error: Dimensions are too small.\nFor platform compatibility, cover image must be at least 300px for both width and height.");
    }

    int estimated_quality = estimateImageQuality(jpg_vec);
    if (estimated_quality > 97) {
        throw std::runtime_error("Image Error: Quality too high. For platform compatibility, cover image quality must be 97 or lower.");
    }
	
    auto ori_opt = exifOrientation(jpg_vec);
    int xop = TJXOP_NONE;
    
    if (ori_opt) {
        xop = getTransformOp(*ori_opt);
    }

    tjtransform xform;
    std::memset(&xform, 0, sizeof(tjtransform));
    xform.op = xop;
   
    xform.options = TJXOPT_COPYNONE | TJXOPT_TRIM;
	
    TJBuffer dstBuffer; 
    unsigned long dstSize = 0;

    if (tjTransform(transformer.get(), jpg_vec.data(), static_cast<unsigned long>(jpg_vec.size()), 1, &dstBuffer.data, &dstSize, &xform, 0) != 0) {
         throw std::runtime_error(std::string("tjTransform: ") + tjGetErrorStr2(transformer.get()));
    }

    if (xop == TJXOP_ROT90 || xop == TJXOP_ROT270 || xop == TJXOP_TRANSPOSE || xop == TJXOP_TRANSVERSE) {
        std::swap(width, height);
    }
    jpg_vec.assign(dstBuffer.data, dstBuffer.data + dstSize);
}

static bool has_valid_filename(const fs::path& p) {
	if (p.empty()) {
    	return false;
	}		
    
    std::string filename = p.filename().string();
    if (filename.empty()) {
    	return false;
    }

    auto valid_char = [](unsigned char c) {
    	return std::isalnum(c) || c == '.' || c == '-' || c == '_' || c == '@' || c == '%';
 	};

    return std::all_of(filename.begin(), filename.end(), valid_char);
}

static bool has_file_extension(const fs::path& p, std::initializer_list<const char*> exts) {
	auto e = p.extension().string();
    std::transform(e.begin(), e.end(), e.begin(), [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
    for (const char* cand : exts) {
    	std::string c = cand;
        std::transform(c.begin(), c.end(), c.begin(), [](unsigned char x){ return static_cast<char>(std::tolower(x)); });
        if (e == c) return true;
    }
    return false;
}

// Sanitizes user-supplied (wide) text so it’s safe to drop into an HTML context while still allowing line breaks. 
// Everything else goes through a switch that HTML-escapes the dangerous characters & < > " ' \`` into their entities (&, <, >, ", ', ``&#96;``), preventing HTML/JS injection;
// Any other character is copied as-is. 
static void replace_problem_chars(std::wstring& s) {
    auto starts_with = [](const std::wstring& t, size_t pos, const std::wstring& needle) -> bool {
        return pos + needle.size() <= t.size() && t.compare(pos, needle.size(), needle) == 0;
    };

    std::wstring out;
    out.reserve(s.size()); 

    for (size_t i = 0; i < s.size(); ++i) {
        wchar_t c = s[i];

        if (c == L'<') {
        	if (starts_with(s, i, L"<br>"))   { out += L"<br>";   i += 3; continue; }
            if (starts_with(s, i, L"<br/>"))  { out += L"<br/>";  i += 4; continue; }
            if (starts_with(s, i, L"<br />")) { out += L"<br />"; i += 5; continue; }
        }

        switch (c) {
            case L'&':  out += L"&amp;";  break;
            case L'<':  out += L"&lt;";   break;
            case L'>':  out += L"&gt;";   break;
            case L'"':  out += L"&quot;"; break;
            case L'\'': out += L"&#39;";  break;   
            case L'`':  out += L"&#96;";  break;

            case L'\r':
                if (i + 1 < s.size() && s[i + 1] == L'\n') ++i; 
                out += L"<br>";
                break;
            case L'\n':
                out += L"<br>";
                break;
	    	case L'\\': 
	    		out.push_back(L'\\');
    			break;
            default:
                out.push_back(c);
                break;
        }
    }
    s.swap(out);
}

// Try to set a UTF-8 C locale; keep C++ locale in sync if it works. (Linux).
static bool force_utf8_locale() {
	if (std::setlocale(LC_ALL, "C.UTF-8") || std::setlocale(LC_ALL, "en_US.UTF-8") || std::setlocale(LC_ALL, "UTF-8")) {
    	try {
			std::locale::global(std::locale(""));
        } catch (...) {
            	// If this throws, we still have the C locale set to UTF-8,
            	// so wide→multibyte functions will be OK; streams may remain default.
        }
        return true;
    }
    return false;
}

// Converts a UTF-16/UTF-32 wstring to a UTF-8 string, using the right API on each platform.

// Windows: WideCharToMultiByte is the canonical way to encode UTF-16 to UTF-8. The first call asks for the required buffer size (passing nullptr as the output pointer), 
// which returns a count including the terminating NUL. The code allocates a std::string of size-1 (so the result has no trailing NUL) and calls the function again to actually write the bytes.
// If either call fails, it throws. It also passes WC_ERR_INVALID_CHARS as a flag to reject lone surrogates.

// On Linux, wcsrtombs converts from the current C locale’s wide encoding to multibyte (UTF-8). It’s used in the standard two-pass pattern: first call with nullptr to get the length,
// then allocate and call again to do the conversion. If the input contains an unconvertible sequence under the current locale, wcsrtombs returns (size_t)-1 and the code throws.
static std::string convert_string(const std::wstring& wide) {
	#ifdef _WIN32
		if (wide.empty()) return {};
    	int size = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, wide.c_str(), -1, nullptr, 0, nullptr, nullptr);

    	if (size <= 0) throw std::runtime_error("WideCharToMultiByte failed.");

    	std::string converted_string(size - 1, 0); 
    	WideCharToMultiByte(CP_UTF8, 0, wide.c_str(), -1, converted_string.data(), size, nullptr, nullptr);
    	return converted_string;
	#else
    	std::mbstate_t state{};
    	const wchar_t* src = wide.data();
    	std::size_t len = std::wcsrtombs(nullptr, &src, 0, &state);
    	if (len == static_cast<size_t>(-1)) throw std::runtime_error("Conversion to UTF-8 failed.");

    	std::string converted_string(len, 0);
    	src = wide.data(); 
    	std::wcsrtombs(converted_string.data(), &src, len, &state);
    	return converted_string;
	#endif
}

// This should provide larger console input for Linux. Default is just 4095 chars.
// Temporarily disables canonical input mode so you can read an arbitrarily long line from a TTY without the ~4 KB line buffer limit. 
// TermiosGuard grabs the current terminal settings in its constructor (tcgetattr), makes a copy, clears ICANON (non-canonical mode),
// sets VMIN=1/VTIME=0 so reads return as soon as one byte is available, and applies the change with tcsetattr.
// It records active=true only if the change succeeded. 
// When the guard goes out of scope, the destructor restores the original settings, guaranteeing cleanup even on exceptions (RAII).

// read_long_line_from_tty() simply instantiates TermiosGuard (activating the temporary mode for the duration of the function) 
// and then pulls characters from std::wcin with get() until it sees a newline, appending each wchar_t to a std::wstring.
#ifdef __unix__
	namespace {  
		struct TermiosGuard {
    		termios old{};
    		bool active = false;
    		TermiosGuard() {
        		if (::isatty(STDIN_FILENO)) {
            		if (::tcgetattr(STDIN_FILENO, &old) == 0) {
                		termios raw = old;
                		raw.c_lflag &= ~ICANON;
                		raw.c_cc[VMIN]  = 1;           
                		raw.c_cc[VTIME] = 0;
                		if (::tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw) == 0) {
                    		active = true;
                		}
            		}
        		}
    		}
    		~TermiosGuard() {
        		if (active) {
            		::tcsetattr(STDIN_FILENO, TCSAFLUSH, &old);
        		}
    		}
		};
	} 
	static std::wstring read_long_line_from_tty() {
		TermiosGuard guard;  
    	std::wstring s;
    	wchar_t ch;
    	while (std::wcin.get(ch)) {
        	if (ch == L'\n') break;
        	s.push_back(ch);
    	}
    	return s;
	}
#endif

// Validate URL.
namespace {
	static bool is_dec(char c) noexcept { return c >= '0' && c <= '9'; }
	static bool is_hex(char c) noexcept {
    	unsigned char u = static_cast<unsigned char>(c);
    	return std::isxdigit(u) != 0;
	}
	
	static bool valid_pct(const std::string& s, std::size_t i) noexcept {
    	return i + 2 < s.size() && is_hex(s[i+1]) && is_hex(s[i+2]);
	}

	static bool valid_ipv4(const std::string& s) noexcept {
    	int dots = 0, val = 0, digits = 0;
    	for (char c : s) {
        	if (c == '.') {
            	if (digits == 0 || val > 255) return false;
            		++dots; val = 0; digits = 0;
        	} else if (is_dec(c)) {
				val = val * 10 + (c - '0');
            	if (val > 255) return false;
            		++digits;
        	} else {
            	return false;
        	}
    	}
    	if (digits == 0 || val > 255) return false;
    	return dots == 3;
	}	

	static bool valid_dns_label(const std::string& lbl) noexcept {
    	if (lbl.empty() || lbl.size() > 63) return false;
    	auto alnum = [](unsigned char c){ return std::isalnum(c) != 0; };
    	if (!alnum(lbl.front()) || !alnum(lbl.back())) return false;
    	for (unsigned char c : lbl)
        if (!(alnum(c) || c == '-')) return false;
    	return true;
	}

	static bool valid_hostname_ascii(const std::string& host) noexcept {
    	if (host.empty() || host.size() > 253) return false;
    	if (host.find("..") != std::string::npos) return false;
    	if (host.back() == '.') return false;
    
    	bool all_digits_or_dot = true;
    	for (unsigned char c : host) {
        	if (!(std::isalnum(c) || c == '-' || c == '.')) return false;
        	if (!(std::isdigit(c) || c == '.')) all_digits_or_dot = false;
    	}
    	if (all_digits_or_dot && valid_ipv4(host)) return true;

    	std::size_t start = 0;
    	while (true) {
        	std::size_t dot = host.find('.', start);
        	std::string lbl = host.substr(start, (dot == std::string::npos) ? std::string::npos : dot - start);
        	if (!valid_dns_label(lbl)) return false;
        	if (dot == std::string::npos) break;
        	start = dot + 1;
    	}
    	return true;
	}

	static bool valid_path_query_ascii(const std::string& s, std::string* err) {
    	for (std::size_t i = 0; i < s.size(); ++i) {
        	unsigned char c = static_cast<unsigned char>(s[i]);
        	if (c < 0x20 || c == 0x7F) { if (err) *err = "Control char in path/query"; return false; }
        	if (c == '#') { if (err) *err = "Fragment ('#') not allowed"; return false; }
        	if (c == '%') {
            	if (!valid_pct(s, i)) { if (err) *err = "Bad percent-encoding"; return false; }
            	i += 2;
            	continue;
        	}
        	if (!(std::isalnum(c) || c=='-'||c=='_'||c=='.'||c=='~' ||
				c==':'||c=='/'||c=='?'||c=='@'||c=='!'||c=='$'||c=='&'||
              		c=='\''||c=='('||c==')'||c=='*'||c=='+'||c==','||c==';'||c=='=')) {
            			if (err) *err = "Illegal character in path/query";
            			return false;
        	}
    	}
    	return true;
	}
}

static bool validate_url_link(const std::string& url, std::string* err = nullptr) {
	auto bad = [&](const char* e){ if (err) *err = e; return false; };
	
 	constexpr char kScheme[] = "https://";
 	
    for (unsigned char c : url)
    	if (c < 0x20 || c == 0x7F) return bad("Control/whitespace not allowed");
    std::size_t pos = sizeof(kScheme) - 1;
    std::size_t slash = url.find('/', pos);
    std::string authority = url.substr(pos, (slash == std::string::npos) ? std::string::npos : slash - pos);
    	
    if (authority.empty()) return bad("Missing host");
    if (authority.find('@') != std::string::npos) return bad("Credentials not allowed");

   	std::string host, port_str;
    std::size_t colon = authority.rfind(':');
    	
    if (colon != std::string::npos) {
    	host = authority.substr(0, colon);
        port_str = authority.substr(colon + 1);
        if (port_str.empty()) return bad("Empty port");
        unsigned long port = 0;
        for (char c : port_str) {
        	if (!is_dec(c)) return bad("Port must be digits");
            port = port * 10 + (c - '0');
            if (port > 65535) return bad("Port out of range");
        }
        if (port == 0) return bad("Port out of range");
    } else {
        host = authority;
    }

    if (!valid_hostname_ascii(host)) return bad("Invalid host");
    if (slash == std::string::npos) return true;

    return valid_path_query_ascii(url.substr(slash), err);
}

static void validate_url_link_core(const std::string& url) {
	std::string err;
    if (!validate_url_link(url, &err)) {
    	throw std::runtime_error(std::string("Link Error: ") + (err.empty() ? "Invalid URL" : err));
    }
}
//--------------

int main(int argc, char** argv) {
	try {
		auto args_opt = program_args::parse(argc, argv);
        if (!args_opt) return 0; 
        	       
      	program_args args = *args_opt;   
		
		if (!fs::exists(args.image_file_path)) {
        	throw std::runtime_error("Image File Error: File not found.");
    	}
			
		if (!has_valid_filename(args.image_file_path)) {
    		throw std::runtime_error("Invalid Input Error: Unsupported characters in filename arguments.");
		}

		if (!has_file_extension(args.image_file_path, {".jpg", ".jpeg", ".jfif"})) {
        	throw std::runtime_error("File Type Error: Invalid image extension. Only expecting \".jpg\", \".jpeg\", or \".jfif\".");
    	}
    			
		std::ifstream jpg_ifs(args.image_file_path, std::ios::binary);
        	
    	if (!jpg_ifs) {
    		throw std::runtime_error("Read File Error: Unable to read image file. Check the filename and try again.");
   		}

		std::size_t jpg_vec_size = fs::file_size(args.image_file_path);

    	constexpr std::size_t MINIMUM_IMAGE_SIZE = 134ULL;

    	if (MINIMUM_IMAGE_SIZE > jpg_vec_size) {
        	throw std::runtime_error("Image File Error: Invalid file size.");
    	}
    	
    	constexpr std::size_t
    		MAX_IMAGE_SIZE_BEFORE_ENCODE  	= 8ULL   * 1024 * 1024,	// 8 MB.
			MAX_IMAGE_SIZE_AFTER_ENCODE		= 4ULL   * 1024 * 1024,	// 4 MB.
    		MAX_IMAGE_SIZE_BLUESKY 			= 912ULL * 1024;		// 912 KB.
    		
    	if (jpg_vec_size > MAX_IMAGE_SIZE_BEFORE_ENCODE) {
			throw std::runtime_error("Image File Error: Cover image file exceeds maximum size limit.");
		}
    		
		vBytes jpg_vec(jpg_vec_size);
	
		jpg_ifs.read(reinterpret_cast<char*>(jpg_vec.data()), jpg_vec_size);
		jpg_ifs.close();
	
    	optimizeImage(jpg_vec);
    		
		constexpr size_t DQT_SEARCH_LIMIT = 100ULL;         
    	constexpr auto 
        	DQT1_SIG = std::to_array<Byte>({ 0xFF, 0xDB, 0x00, 0x43 }),    
       		DQT2_SIG = std::to_array<Byte>({ 0xFF, 0xDB, 0x00, 0x84 });
                
    	auto
    		dqt1 = searchSig(jpg_vec, std::span<const Byte>(DQT1_SIG), DQT_SEARCH_LIMIT),
        	dqt2 = searchSig(jpg_vec, std::span<const Byte>(DQT2_SIG), DQT_SEARCH_LIMIT);

    	if (!dqt1 && !dqt2) {
    		throw std::runtime_error("Image File Error: No DQT segment found (corrupt or unsupported JPG).");
    	}

    	const std::size_t NPOS = static_cast<std::size_t>(-1);
            
    	std::size_t dqt_pos = std::min(dqt1.value_or(NPOS), dqt2.value_or(NPOS));
            
    	// Erase everything before DQT.
    	// This leaves the cover image with NO Start of Image (SOI) marker. 
    	// We will write this back later via segment_vec or bluesky_vec.
    	jpg_vec.erase(jpg_vec.begin(), jpg_vec.begin() + static_cast<std::ptrdiff_t>(dqt_pos));

    	jpg_vec_size = jpg_vec.size(); 
			const bool isBluesky = (args.option == Option::Bluesky);
		if (jpg_vec_size > MAX_IMAGE_SIZE_AFTER_ENCODE) {
			throw std::runtime_error("Image File Error: Image exceeds maximum size limit.");
		}
			
		if (isBluesky && jpg_vec_size > MAX_IMAGE_SIZE_BLUESKY) {
			throw std::runtime_error("Image File Error: Image exceeds maximum size limit for Bluesky.");
		}
		
		std::cout << "\n*** imgprmt v1.3 ***\n";

		#ifdef _WIN32
			// Try to give std::wcin a larger buffer
			constexpr std::size_t WIN_BUFFER_SIZE = 65535ULL;
   			static std::vector<wchar_t> win_inbuf(WIN_BUFFER_SIZE);
    		std::wcin.rdbuf()->pubsetbuf(win_inbuf.data(), win_inbuf.size());
			
			// Flushes pending output. Ensures nothing buffered is stuck before switching modes.
   			std::wcout.flush();
   			std::cout.flush();

			// Detects TTY vs pipe. Chooses text mode.
			// TTY ⇒ _O_U16TEXT: the MSVCRT will read/write UTF-16 to/from the Windows console API (best for correct Unicode at the console).
			// Pipe/file ⇒ _O_BINARY: avoids CR/LF translation and lets you control encoding at the byte level (good for piping).
			// Applies the modes and remembers old ones, which are restored later at end of program.
   			bool 
   				stdin_is_tty  = (_isatty(_fileno(stdin))  != 0),
  				stdout_is_tty = (_isatty(_fileno(stdout)) != 0);
			
    		int 
    			desired_in_mode  = stdin_is_tty  ? _O_U16TEXT : _O_BINARY,
    			desired_out_mode = stdout_is_tty ? _O_U16TEXT : _O_BINARY,
    			old_stdin_mode   = _setmode(_fileno(stdin),  desired_in_mode),
    			old_stdout_mode  = _setmode(_fileno(stdout), desired_out_mode);
		#else
			if (!force_utf8_locale()) {
        		throw std::runtime_error(
           			"UTF-8 locale is required. Please install/enable a UTF-8 locale "
					"(e.g., C.UTF-8 or en_US.UTF-8) and try again.");
   			}

   			// Imbue wide streams with the (now UTF-8) global locale
    		const std::locale loc("");   // current global
    		std::wcin.imbue(loc);
    		std::wcout.imbue(loc);
    		std::wcerr.imbue(loc);
		#endif
	
		std::wstring
			wprompt,
			wurl;

		constexpr size_t
			URL_MIN_CHARS = 12ULL,
			URL_MAX_CHARS = 200ULL;
			
		std::wcout << L"\nEnter a web address (Your site, social media page, etc).\nFull URL: ";
		std::getline(std::wcin, wurl);
	
		const std::wstring prefix = L"https://";
		
		if (URL_MIN_CHARS > wurl.length() || wurl.substr(0, prefix.length()) != prefix || wurl.length() > URL_MAX_CHARS) {
			throw std::runtime_error("Link Error: URL must start with 'https://', have a minimun length of 12 characters and not exceed 200 characters.");
		}
		
		uint16_t 
			default_max_bytes = static_cast<uint16_t>(57140 - wurl.length()),
			twitter_max_bytes = static_cast<uint16_t>(1845 - wurl.length());
			
		if (args.option == Option::None) { 
			std::wcout << L"\nDefault byte limit: " << default_max_bytes << " | X-Twitter byte limit: " << twitter_max_bytes << ".\n";
		} else {
			std::wcout << L"\nDefault byte limit: " << default_max_bytes << ".\n";
		}
		
		std::wcout << L"\nType or paste in your prompt as one long sentence."; 
		std::wcout << L"\nIf required, add <br> tags to your text for new lines.\n\nPrompt: ";
		
		#ifdef _WIN32 
			std::getline(std::wcin, wprompt); 
		#else 
			wprompt = read_long_line_from_tty(); 
		#endif

		replace_problem_chars(wprompt);

		std::string utf8_url = convert_string(wurl);
		validate_url_link_core(utf8_url);
		
		std::wstring().swap(wurl);
		
		std::string utf8_prompt = convert_string(wprompt);
		std::wstring().swap(wprompt);
		
		// Color Profile (X-Twitter, Mastodon, Pixelfed, Tumblr & Flickr). The vector is inserted into the main default segment vector.
		vBytes profile_vec {
			0xFF, 0xE2, 0x00, 0x00, 0x49, 0x43, 0x43, 0x5F, 0x50, 0x52, 0x4F, 0x46, 0x49, 0x4C, 0x45, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x21,
			0x2D, 0x2D, 0x04, 0x20, 0x00, 0x00, 0x6D, 0x6E, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5A, 0x20, 0x07, 0xE5, 0x00, 0x04, 0x00, 0x1B,
			0x00, 0x0A, 0x00, 0x1B, 0x00, 0x00, 0x61, 0x63, 0x73, 0x70, 0x4D, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00, 0x73, 0x61, 0x77, 0x73, 0x63, 0x74,
			0x72, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0xD6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
			0xD3, 0x2D, 0x68, 0x61, 0x6E, 0x64, 0x40, 0x92, 0xFF, 0x1E, 0x67, 0x34, 0xB5, 0x6D, 0x00, 0x1C, 0x4E, 0x36, 0x73, 0x3F, 0x4E, 0x71, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x24, 0x63, 0x70, 0x72, 0x74, 0x00, 0x00,
			0x01, 0x20, 0x00, 0x00, 0x00, 0x22, 0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00, 0x00, 0x14, 0x63, 0x68, 0x61, 0x64, 0x00, 0x00,
			0x01, 0x58, 0x00, 0x00, 0x00, 0x2C, 0x72, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x01, 0x84, 0x00, 0x00, 0x00, 0x14, 0x67, 0x58, 0x59, 0x5A, 0x00, 0x00,
			0x01, 0x98, 0x00, 0x00, 0x00, 0x14, 0x62, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x01, 0xAC, 0x00, 0x00, 0x00, 0x14, 0x72, 0x54, 0x52, 0x43, 0x00, 0x00,
			0x01, 0xC0, 0x00, 0x00, 0x00, 0x20, 0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x20, 0x62, 0x54, 0x52, 0x43, 0x00, 0x00,
			0x01, 0xC0, 0x00, 0x00, 0x00, 0x20, 0x6D, 0x6C, 0x75, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x65, 0x6E,
			0x55, 0x53, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x41, 0x00, 0x39, 0x00, 0x38, 0x00, 0x43, 0x6D, 0x6C, 0x75, 0x63, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x65, 0x6E, 0x55, 0x53, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x43,
			0x00, 0x43, 0x00, 0x30, 0x00, 0x00, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0xD6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
			0xD3, 0x2D, 0x73, 0x66, 0x33, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0C, 0x42, 0x00, 0x00, 0x05, 0xDE, 0xFF, 0xFF, 0xF3, 0x25, 0x00, 0x00,
			0x07, 0x93, 0x00, 0x00, 0xFD, 0x90, 0xFF, 0xFF, 0xFB, 0xA1, 0xFF, 0xFF, 0xFD, 0xA2, 0x00, 0x00, 0x03, 0xDC, 0x00, 0x00, 0xC0, 0x6E, 0x58, 0x59,
			0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x18, 0x00, 0x00, 0x4F, 0xA5, 0x00, 0x00, 0x04, 0xFC, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x34, 0x8D, 0x00, 0x00, 0xA0, 0x2C, 0x00, 0x00, 0x0F, 0x95, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x26, 0x31, 0x00, 0x00, 0x10, 0x2F, 0x00, 0x00, 0xBE, 0x9C, 0x70, 0x61, 0x72, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02,
			0x33, 0x33, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0E, 0x41
		};
		
		// If option -b selected. This vector contains the basic EXIF segment required for BlueSky. Color profile not supported by BlueSky.
		// Currently without webpage, user's image prompt & URL; which is inserted later. The contents of segment_vec (not including JPG header) is inserted
		// into this vector.
		vBytes bluesky_vec {
			0xFF, 0xD8, 0xFF, 0xE1, 0x1A, 0xDC, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4D, 0x4D, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x08, 0x00, 0x06, 0x01, 0x12,
			0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x1A, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0xA6, 0x01, 0x1B,
			0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0xAE, 0x01, 0x28, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x01, 0x3B,
			0x00, 0x02, 0x00, 0x00, 0x1A, 0x4F, 0x00, 0x00, 0x00, 0x56, 0x87, 0x69, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0xB6, 0x00, 0x00,
			0x00, 0x00, 0x43, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20,
			0x74, 0x6F, 0x20, 0x2E, 0x68, 0x74, 0x6D, 0x20, 0x74, 0x6F, 0x20, 0x76, 0x69, 0x65, 0x77, 0x20, 0x65, 0x6D, 0x62, 0x65, 0x64, 0x64, 0x65, 0x64,
			0x20, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x2F, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F,
			0x6E, 0x2E, 0x20, 0x69, 0x6D, 0x67, 0x70, 0x72, 0x6D, 0x74, 0x20, 0x76, 0x31, 0x2E, 0x33, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
			0x62, 0x79, 0x20, 0x4E, 0x69, 0x63, 0x68, 0x6F, 0x6C, 0x61, 0x73, 0x20, 0x43, 0x6C, 0x65, 0x61, 0x73, 0x62, 0x79, 0x20, 0x28, 0x40, 0x43, 0x6C,
			0x65, 0x61, 0x73, 0x62, 0x79, 0x43, 0x6F, 0x64, 0x65, 0x29, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
			0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0xA0, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0xE8, 0xA0, 0x03, 0x00, 0x04, 0x00,
			0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0xF1, 0x00, 0x00, 0x00, 0x00
		};
		
		// Main segment vector containing JPG header and basic webpage to display user's image prompt. This vector is either inserted into bluesky_vec, if
		// -b option selected (not including JPG header bytes), or profile_vec is inserted into this vector, default (no option selected).
		vBytes segment_vec {
			0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0x2D, 0x2D, 0x3E, 0x3C,
			0x21, 0x44, 0x4F, 0x43, 0x54, 0x59, 0x50, 0x45, 0x20, 0x68, 0x74, 0x6D, 0x6C, 0x3E, 0x3C, 0x68, 0x74, 0x6D, 0x6C, 0x20, 0x6C, 0x61, 0x6E, 0x67,
			0x3D, 0x22, 0x65, 0x6E, 0x22, 0x3E, 0x3C, 0x68, 0x65, 0x61, 0x64, 0x3E, 0x3C, 0x6D, 0x65, 0x74, 0x61, 0x20, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65,
			0x74, 0x3D, 0x22, 0x75, 0x74, 0x66, 0x2D, 0x38, 0x22, 0x3E, 0x3C, 0x6D, 0x65, 0x74, 0x61, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x22, 0x76, 0x69,
			0x65, 0x77, 0x70, 0x6F, 0x72, 0x74, 0x22, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x22, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3D, 0x64,
			0x65, 0x76, 0x69, 0x63, 0x65, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x2C, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x2D, 0x73, 0x63, 0x61,
			0x6C, 0x65, 0x3D, 0x31, 0x22, 0x3E, 0x3C, 0x74, 0x69, 0x74, 0x6C, 0x65, 0x3E, 0x49, 0x4D, 0x47, 0x50, 0x52, 0x4D, 0x54, 0x3C, 0x2F, 0x74, 0x69,
			0x74, 0x6C, 0x65, 0x3E, 0x3C, 0x6D, 0x65, 0x74, 0x61, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x22, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x2D, 0x73, 0x63,
			0x68, 0x65, 0x6D, 0x65, 0x22, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x22, 0x64, 0x61, 0x72, 0x6B, 0x20, 0x6C, 0x69, 0x67, 0x68,
			0x74, 0x22, 0x3E, 0x3C, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x72, 0x65, 0x6C, 0x3D, 0x22, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74,
			0x22, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x73, 0x2E, 0x67, 0x6F,
			0x6F, 0x67, 0x6C, 0x65, 0x61, 0x70, 0x69, 0x73, 0x2E, 0x63, 0x6F, 0x6D, 0x22, 0x3E, 0x3C, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x72, 0x65, 0x6C, 0x3D,
			0x22, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x22, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73,
			0x3A, 0x2F, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x73, 0x2E, 0x67, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x22, 0x20, 0x63, 0x72,
			0x6F, 0x73, 0x73, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x3E, 0x3C, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x68, 0x74,
			0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x73, 0x2E, 0x67, 0x6F, 0x6F, 0x67, 0x6C, 0x65, 0x61, 0x70, 0x69, 0x73, 0x2E, 0x63,
			0x6F, 0x6D, 0x2F, 0x63, 0x73, 0x73, 0x32, 0x3F, 0x66, 0x61, 0x6D, 0x69, 0x6C, 0x79, 0x3D, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x3A, 0x77, 0x67, 0x68,
			0x74, 0x40, 0x34, 0x30, 0x30, 0x3B, 0x35, 0x30, 0x30, 0x3B, 0x36, 0x30, 0x30, 0x3B, 0x37, 0x30, 0x30, 0x26, 0x66, 0x61, 0x6D, 0x69, 0x6C, 0x79,
			0x3D, 0x50, 0x6C, 0x75, 0x73, 0x2B, 0x4A, 0x61, 0x6B, 0x61, 0x72, 0x74, 0x61, 0x2B, 0x53, 0x61, 0x6E, 0x73, 0x3A, 0x77, 0x67, 0x68, 0x74, 0x40,
			0x34, 0x30, 0x30, 0x3B, 0x36, 0x30, 0x30, 0x26, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3D, 0x73, 0x77, 0x61, 0x70, 0x22, 0x20, 0x72, 0x65,
			0x6C, 0x3D, 0x22, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x73, 0x68, 0x65, 0x65, 0x74, 0x22, 0x3E, 0x3C, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3E, 0x64,
			0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x61, 0x64, 0x64, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4C, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x65, 0x72,
			0x28, 0x22, 0x44, 0x4F, 0x4D, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x4C, 0x6F, 0x61, 0x64, 0x65, 0x64, 0x22, 0x2C, 0x28, 0x29, 0x3D, 0x3E,
			0x7B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x3D, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x6C, 0x6F, 0x63, 0x61, 0x74,
			0x69, 0x6F, 0x6E, 0x2E, 0x70, 0x61, 0x74, 0x68, 0x6E, 0x61, 0x6D, 0x65, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x66, 0x6E, 0x61, 0x6D, 0x65,
			0x3D, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x73, 0x70, 0x6C, 0x69, 0x74, 0x28, 0x22, 0x2F, 0x22, 0x29, 0x2E, 0x70, 0x6F, 0x70, 0x28, 0x29, 0x3B, 0x64,
			0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x48, 0x54, 0x4D, 0x4C, 0x3D, 0x60,
			0x3C, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3E, 0x3A, 0x72, 0x6F, 0x6F, 0x74, 0x7B, 0x2D, 0x2D, 0x62, 0x67, 0x2D, 0x73, 0x74, 0x61, 0x72, 0x74, 0x3A,
			0x23, 0x30, 0x38, 0x31, 0x38, 0x32, 0x30, 0x3B, 0x2D, 0x2D, 0x62, 0x67, 0x2D, 0x65, 0x6E, 0x64, 0x3A, 0x23, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
			0x3B, 0x2D, 0x2D, 0x74, 0x65, 0x78, 0x74, 0x3A, 0x23, 0x65, 0x61, 0x66, 0x30, 0x66, 0x66, 0x3B, 0x2D, 0x2D, 0x6D, 0x75, 0x74, 0x65, 0x64, 0x3A,
			0x23, 0x62, 0x37, 0x63, 0x30, 0x64, 0x36, 0x3B, 0x2D, 0x2D, 0x62, 0x72, 0x61, 0x6E, 0x64, 0x3A, 0x23, 0x38, 0x61, 0x34, 0x63, 0x66, 0x30, 0x3B,
			0x2D, 0x2D, 0x62, 0x72, 0x61, 0x6E, 0x64, 0x2D, 0x32, 0x3A, 0x23, 0x35, 0x35, 0x37, 0x66, 0x64, 0x38, 0x3B, 0x2D, 0x2D, 0x63, 0x61, 0x72, 0x64,
			0x3A, 0x23, 0x30, 0x65, 0x31, 0x66, 0x33, 0x66, 0x3B, 0x2D, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x30, 0x20, 0x31, 0x32, 0x70, 0x78,
			0x20, 0x33, 0x30, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x2E, 0x34, 0x29, 0x2C, 0x30, 0x20, 0x32,
			0x70, 0x78, 0x20, 0x38, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x2E, 0x33, 0x35, 0x29, 0x3B, 0x7D,
			0x68, 0x74, 0x6D, 0x6C, 0x2C, 0x62, 0x6F, 0x64, 0x79, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x30, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D,
			0x66, 0x61, 0x6D, 0x69, 0x6C, 0x79, 0x3A, 0x22, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x22, 0x2C, 0x22, 0x50, 0x6C, 0x75, 0x73, 0x20, 0x4A, 0x61, 0x6B,
			0x61, 0x72, 0x74, 0x61, 0x20, 0x53, 0x61, 0x6E, 0x73, 0x22, 0x2C, 0x22, 0x53, 0x65, 0x67, 0x6F, 0x65, 0x20, 0x55, 0x49, 0x22, 0x2C, 0x73, 0x79,
			0x73, 0x74, 0x65, 0x6D, 0x2D, 0x75, 0x69, 0x2C, 0x2D, 0x61, 0x70, 0x70, 0x6C, 0x65, 0x2D, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2C, 0x52, 0x6F,
			0x62, 0x6F, 0x74, 0x6F, 0x2C, 0x41, 0x72, 0x69, 0x61, 0x6C, 0x2C, 0x73, 0x61, 0x6E, 0x73, 0x2D, 0x73, 0x65, 0x72, 0x69, 0x66, 0x3B, 0x63, 0x6F,
			0x6C, 0x6F, 0x72, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x62, 0x67, 0x2D, 0x65, 0x6E, 0x64, 0x29, 0x3B, 0x62,
			0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x20, 0x21, 0x69, 0x6D,
			0x70, 0x6F, 0x72, 0x74, 0x61, 0x6E, 0x74, 0x3B, 0x6D, 0x69, 0x6E, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x30, 0x30, 0x64, 0x76,
			0x68, 0x3B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x66, 0x6C, 0x65, 0x78, 0x2D, 0x64, 0x69, 0x72, 0x65,
			0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x3B, 0x6F, 0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x2D, 0x78, 0x3A,
			0x68, 0x69, 0x64, 0x64, 0x65, 0x6E, 0x3B, 0x7D, 0x62, 0x6F, 0x64, 0x79, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x30, 0x3B, 0x66, 0x6F,
			0x6E, 0x74, 0x2D, 0x66, 0x61, 0x6D, 0x69, 0x6C, 0x79, 0x3A, 0x22, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x22, 0x2C, 0x22, 0x50, 0x6C, 0x75, 0x73, 0x20,
			0x4A, 0x61, 0x6B, 0x61, 0x72, 0x74, 0x61, 0x20, 0x53, 0x61, 0x6E, 0x73, 0x22, 0x2C, 0x22, 0x53, 0x65, 0x67, 0x6F, 0x65, 0x20, 0x55, 0x49, 0x22,
			0x2C, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2D, 0x75, 0x69, 0x2C, 0x2D, 0x61, 0x70, 0x70, 0x6C, 0x65, 0x2D, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D,
			0x2C, 0x52, 0x6F, 0x62, 0x6F, 0x74, 0x6F, 0x2C, 0x41, 0x72, 0x69, 0x61, 0x6C, 0x2C, 0x73, 0x61, 0x6E, 0x73, 0x2D, 0x73, 0x65, 0x72, 0x69, 0x66,
			0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67,
			0x72, 0x6F, 0x75, 0x6E, 0x64, 0x3A, 0x72, 0x61, 0x64, 0x69, 0x61, 0x6C, 0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x32,
			0x30, 0x30, 0x70, 0x78, 0x20, 0x38, 0x30, 0x30, 0x70, 0x78, 0x20, 0x61, 0x74, 0x20, 0x32, 0x30, 0x25, 0x20, 0x2D, 0x31, 0x30, 0x25, 0x2C, 0x23,
			0x30, 0x66, 0x32, 0x62, 0x35, 0x61, 0x20, 0x30, 0x25, 0x2C, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x36, 0x30,
			0x25, 0x29, 0x2C, 0x72, 0x61, 0x64, 0x69, 0x61, 0x6C, 0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x30, 0x30, 0x30, 0x70,
			0x78, 0x20, 0x31, 0x30, 0x30, 0x30, 0x70, 0x78, 0x20, 0x61, 0x74, 0x20, 0x31, 0x32, 0x30, 0x25, 0x20, 0x31, 0x30, 0x25, 0x2C, 0x23, 0x30, 0x61,
			0x31, 0x66, 0x34, 0x35, 0x20, 0x30, 0x25, 0x2C, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x35, 0x35, 0x25, 0x29,
			0x2C, 0x6C, 0x69, 0x6E, 0x65, 0x61, 0x72, 0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x38, 0x30, 0x64, 0x65, 0x67, 0x2C,
			0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x62, 0x67, 0x2D, 0x73, 0x74, 0x61, 0x72, 0x74, 0x29, 0x2C, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x62, 0x67,
			0x2D, 0x65, 0x6E, 0x64, 0x29, 0x29, 0x3B, 0x6D, 0x69, 0x6E, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x30, 0x30, 0x64, 0x76, 0x68,
			0x3B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x66, 0x6C, 0x65, 0x78, 0x2D, 0x64, 0x69, 0x72, 0x65, 0x63,
			0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x3B, 0x7D, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x7B, 0x77, 0x69, 0x64, 0x74,
			0x68, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x3A, 0x32, 0x34, 0x70, 0x78, 0x20, 0x31, 0x36, 0x70, 0x78,
			0x20, 0x38, 0x70, 0x78, 0x20, 0x31, 0x36, 0x70, 0x78, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x3A, 0x63, 0x65, 0x6E,
			0x74, 0x65, 0x72, 0x3B, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3B, 0x7D, 0x68,
			0x31, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x2D, 0x38, 0x70, 0x78, 0x20, 0x30, 0x20, 0x31, 0x36, 0x70, 0x78, 0x20, 0x30, 0x3B, 0x66,
			0x6F, 0x6E, 0x74, 0x2D, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x37, 0x30, 0x30, 0x3B, 0x6C, 0x65, 0x74, 0x74, 0x65, 0x72, 0x2D, 0x73, 0x70,
			0x61, 0x63, 0x69, 0x6E, 0x67, 0x3A, 0x2E, 0x33, 0x70, 0x78, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x63, 0x6C, 0x61,
			0x6D, 0x70, 0x28, 0x32, 0x34, 0x70, 0x78, 0x2C, 0x34, 0x2E, 0x35, 0x76, 0x77, 0x2C, 0x34, 0x36, 0x70, 0x78, 0x29, 0x3B, 0x6C, 0x69, 0x6E, 0x65,
			0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x2E, 0x32, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x77, 0x72, 0x61, 0x70, 0x3A, 0x62, 0x61,
			0x6C, 0x61, 0x6E, 0x63, 0x65, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6C,
			0x69, 0x6E, 0x65, 0x61, 0x72, 0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x39, 0x30, 0x64, 0x65, 0x67, 0x2C, 0x23, 0x66, 0x66,
			0x36, 0x62, 0x36, 0x62, 0x20, 0x30, 0x25, 0x2C, 0x23, 0x66, 0x66, 0x39, 0x66, 0x34, 0x33, 0x20, 0x31, 0x32, 0x25, 0x2C, 0x23, 0x66, 0x66, 0x64,
			0x39, 0x33, 0x64, 0x20, 0x32, 0x34, 0x25, 0x2C, 0x23, 0x34, 0x64, 0x64, 0x34, 0x61, 0x30, 0x20, 0x33, 0x36, 0x25, 0x2C, 0x23, 0x32, 0x62, 0x64,
			0x31, 0x66, 0x63, 0x20, 0x34, 0x38, 0x25, 0x2C, 0x20, 0x23, 0x36, 0x61, 0x61, 0x38, 0x66, 0x66, 0x20, 0x36, 0x30, 0x25, 0x2C, 0x23, 0x37, 0x62,
			0x36, 0x31, 0x66, 0x66, 0x20, 0x37, 0x32, 0x25, 0x2C, 0x23, 0x62, 0x33, 0x36, 0x62, 0x66, 0x66, 0x20, 0x38, 0x34, 0x25, 0x2C, 0x23, 0x66, 0x66,
			0x36, 0x62, 0x64, 0x36, 0x20, 0x31, 0x30, 0x30, 0x25, 0x29, 0x3B, 0x2D, 0x77, 0x65, 0x62, 0x6B, 0x69, 0x74, 0x2D, 0x62, 0x61, 0x63, 0x6B, 0x67,
			0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x63, 0x6C, 0x69, 0x70, 0x3A, 0x74, 0x65, 0x78, 0x74, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x2D, 0x63, 0x6C, 0x69, 0x70, 0x3A, 0x74, 0x65, 0x78, 0x74, 0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73,
			0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x33,
			0x30, 0x30, 0x25, 0x20, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x62, 0x61, 0x63, 0x6B,
			0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x2E, 0x33, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73,
			0x65, 0x2C, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x3B, 0x7D, 0x20, 0x68, 0x31, 0x3A,
			0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F,
			0x6E, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x20, 0x30, 0x3B, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65,
			0x73, 0x73, 0x28, 0x31, 0x2E, 0x30, 0x35, 0x29, 0x3B, 0x7D, 0x68, 0x31, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62, 0x61, 0x63, 0x6B, 0x67,
			0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x20, 0x30, 0x3B, 0x66, 0x69,
			0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x31, 0x2E, 0x30, 0x35, 0x29, 0x3B, 0x7D, 0x68,
			0x31, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74,
			0x69, 0x6F, 0x6E, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x20, 0x30, 0x3B, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74,
			0x6E, 0x65, 0x73, 0x73, 0x28, 0x31, 0x2E, 0x30, 0x35, 0x29, 0x3B, 0x7D, 0x2E, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x7B, 0x64, 0x69, 0x73,
			0x70, 0x6C, 0x61, 0x79, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x3B, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x6C, 0x61,
			0x74, 0x69, 0x76, 0x65, 0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x70, 0x78, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x3A, 0x70, 0x75, 0x72, 0x70, 0x6C, 0x65, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x3A, 0x30, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69,
			0x6E, 0x3A, 0x30, 0x3B, 0x6C, 0x65, 0x66, 0x74, 0x3A, 0x35, 0x30, 0x25, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x63, 0x61, 0x6C, 0x63, 0x28,
			0x31, 0x30, 0x30, 0x76, 0x77, 0x20, 0x2B, 0x20, 0x38, 0x70, 0x78, 0x29, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x6C, 0x65, 0x66, 0x74,
			0x3A, 0x63, 0x61, 0x6C, 0x63, 0x28, 0x2D, 0x35, 0x30, 0x76, 0x77, 0x20, 0x2D, 0x20, 0x34, 0x70, 0x78, 0x29, 0x3B, 0x7D, 0x6D, 0x61, 0x69, 0x6E,
			0x7B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x6D, 0x69,
			0x6E, 0x28, 0x31, 0x30, 0x30, 0x30, 0x70, 0x78, 0x2C, 0x39, 0x32, 0x76, 0x77, 0x29, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x69, 0x6E,
			0x6C, 0x69, 0x6E, 0x65, 0x3A, 0x61, 0x75, 0x74, 0x6F, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x3A, 0x63, 0x65, 0x6E,
			0x74, 0x65, 0x72, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x70, 0x3A, 0x63, 0x6C, 0x61, 0x6D, 0x70, 0x28, 0x30, 0x76, 0x68,
			0x2C, 0x35, 0x2E, 0x35, 0x76, 0x68, 0x2C, 0x38, 0x2E, 0x35, 0x76, 0x68, 0x29, 0x3B, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x3A, 0x30, 0x20,
			0x31, 0x32, 0x70, 0x78, 0x20, 0x36, 0x34, 0x70, 0x78, 0x20, 0x31, 0x32, 0x70, 0x78, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66,
			0x72, 0x61, 0x6D, 0x65, 0x7B, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3B, 0x64,
			0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x2D, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x3A,
			0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x6A, 0x75, 0x73, 0x74, 0x69, 0x66, 0x79, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3A, 0x63,
			0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x69, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x3A, 0x61, 0x75, 0x74, 0x6F,
			0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x6D, 0x69, 0x6E, 0x28, 0x35, 0x39, 0x30, 0x2E, 0x34, 0x70, 0x78, 0x2C, 0x36,
			0x32, 0x2E, 0x39, 0x38, 0x32, 0x76, 0x77, 0x29, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x34, 0x35, 0x2E, 0x39,
			0x76, 0x68, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2D, 0x72, 0x61, 0x64, 0x69, 0x75, 0x73, 0x3A, 0x31, 0x38, 0x70, 0x78, 0x3B, 0x62, 0x6F,
			0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x29, 0x3B, 0x6F,
			0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x3A, 0x68, 0x69, 0x64, 0x64, 0x65, 0x6E, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x3A, 0x32, 0x70,
			0x78, 0x20, 0x73, 0x6F, 0x6C, 0x69, 0x64, 0x20, 0x73, 0x69, 0x6C, 0x76, 0x65, 0x72, 0x3B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x6F,
			0x6E, 0x3A, 0x62, 0x6F, 0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62,
			0x6F, 0x72, 0x64, 0x65, 0x72, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x66, 0x69,
			0x6C, 0x74, 0x65, 0x72, 0x20, 0x2E, 0x32, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66, 0x72,
			0x61, 0x6D, 0x65, 0x20, 0x69, 0x6D, 0x67, 0x7B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x3B, 0x6D, 0x61,
			0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A,
			0x31, 0x30, 0x30, 0x25, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x61, 0x75, 0x74, 0x6F, 0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x61,
			0x75, 0x74, 0x6F, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x30, 0x20, 0x61, 0x75, 0x74, 0x6F, 0x3B, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74,
			0x2D, 0x66, 0x69, 0x74, 0x3A, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x7D, 0x2E, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x7B, 0x6D, 0x61,
			0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x70, 0x3A, 0x32, 0x34, 0x70, 0x78, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x62, 0x6F, 0x74,
			0x74, 0x6F, 0x6D, 0x3A, 0x31, 0x30, 0x70, 0x78, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x7B, 0x2D, 0x2D, 0x70, 0x61, 0x64, 0x2D, 0x79, 0x3A, 0x31,
			0x30, 0x70, 0x78, 0x3B, 0x2D, 0x2D, 0x70, 0x61, 0x64, 0x2D, 0x78, 0x3A, 0x31, 0x38, 0x70, 0x78, 0x3B, 0x2D, 0x2D, 0x72, 0x61, 0x64, 0x69, 0x75,
			0x73, 0x3A, 0x39, 0x39, 0x39, 0x70, 0x78, 0x3B, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x3B,
			0x63, 0x75, 0x72, 0x73, 0x6F, 0x72, 0x3A, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x75, 0x73, 0x65, 0x72, 0x2D, 0x73, 0x65, 0x6C, 0x65,
			0x63, 0x74, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x3B, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x70, 0x61,
			0x64, 0x2D, 0x79, 0x29, 0x20, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x70, 0x61, 0x64, 0x2D, 0x78, 0x29, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72,
			0x2D, 0x72, 0x61, 0x64, 0x69, 0x75, 0x73, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x72, 0x61, 0x64, 0x69, 0x75, 0x73, 0x29, 0x3B, 0x66, 0x6F,
			0x6E, 0x74, 0x2D, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x34, 0x30, 0x30, 0x3B, 0x6C, 0x65, 0x74, 0x74, 0x65, 0x72, 0x2D, 0x73, 0x70, 0x61,
			0x63, 0x69, 0x6E, 0x67, 0x3A, 0x2E, 0x32, 0x70, 0x78, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x31, 0x35, 0x70, 0x78,
			0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6C, 0x69, 0x6E, 0x65, 0x61, 0x72,
			0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x33, 0x35, 0x64, 0x65, 0x67, 0x2C, 0x23, 0x34, 0x65, 0x32, 0x32, 0x61, 0x64,
			0x2C, 0x23, 0x32, 0x62, 0x33, 0x66, 0x38, 0x34, 0x29, 0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x77, 0x68, 0x69, 0x74, 0x65, 0x3B, 0x62, 0x6F,
			0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x30, 0x20, 0x31, 0x30, 0x70, 0x78, 0x20, 0x31, 0x38, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62,
			0x61, 0x28, 0x34, 0x30, 0x2C, 0x35, 0x36, 0x2C, 0x39, 0x34, 0x2C, 0x2E, 0x32, 0x38, 0x29, 0x2C, 0x30, 0x20, 0x34, 0x70, 0x78, 0x20, 0x31, 0x30,
			0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x34, 0x38, 0x2C, 0x32, 0x30, 0x2C, 0x38, 0x38, 0x2C, 0x2E, 0x32, 0x35, 0x29, 0x3B, 0x74, 0x72,
			0x61, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x2E, 0x31, 0x35, 0x73, 0x20,
			0x65, 0x61, 0x73, 0x65, 0x2C, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 0x2E, 0x31, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62, 0x6F,
			0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x20, 0x2E, 0x32, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72,
			0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x2E, 0x32, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x63, 0x6F, 0x6C, 0x6F, 0x72,
			0x20, 0x2E, 0x32, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x3A, 0x20, 0x33, 0x70, 0x78, 0x20, 0x73, 0x6F,
			0x6C, 0x69, 0x64, 0x20, 0x70, 0x75, 0x72, 0x70, 0x6C, 0x65, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62,
			0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6C, 0x69, 0x6E, 0x65, 0x61, 0x72, 0x2D, 0x67,
			0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x33, 0x35, 0x64, 0x65, 0x67, 0x2C, 0x23, 0x38, 0x62, 0x37, 0x63, 0x66, 0x30, 0x2C, 0x23,
			0x61, 0x34, 0x39, 0x35, 0x66, 0x35, 0x29, 0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x23, 0x31, 0x62, 0x31, 0x62, 0x32, 0x64, 0x3B, 0x66, 0x69,
			0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x31, 0x2E, 0x31, 0x32, 0x29, 0x3B, 0x74, 0x72,
			0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72, 0x6D, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x59, 0x28, 0x2D, 0x31, 0x70, 0x78, 0x29,
			0x3B, 0x62, 0x6F, 0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x30, 0x20, 0x31, 0x34, 0x70, 0x78, 0x20, 0x32, 0x34, 0x70, 0x78, 0x20,
			0x72, 0x67, 0x62, 0x61, 0x28, 0x34, 0x30, 0x2C, 0x35, 0x36, 0x2C, 0x39, 0x34, 0x2C, 0x2E, 0x33, 0x34, 0x29, 0x2C, 0x30, 0x20, 0x36, 0x70, 0x78,
			0x20, 0x31, 0x34, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x34, 0x38, 0x2C, 0x32, 0x30, 0x2C, 0x38, 0x38, 0x2C, 0x2E, 0x33, 0x29, 0x3B,
			0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x7B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72, 0x6D, 0x3A, 0x74,
			0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x59, 0x28, 0x30, 0x29, 0x3B, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67,
			0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x2E, 0x39, 0x34, 0x29, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B,
			0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x31, 0x2E, 0x30, 0x36, 0x29, 0x3B,
			0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72, 0x6D, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x59, 0x28, 0x2D, 0x31, 0x70,
			0x78, 0x29, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x7B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72,
			0x6D, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x59, 0x28, 0x30, 0x29, 0x3B, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62,
			0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x2E, 0x39, 0x35, 0x29, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x66, 0x6F, 0x63,
			0x75, 0x73, 0x2D, 0x76, 0x69, 0x73, 0x69, 0x62, 0x6C, 0x65, 0x7B, 0x6F, 0x75, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0x3A, 0x33, 0x70, 0x78, 0x20, 0x73,
			0x6F, 0x6C, 0x69, 0x64, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x31, 0x35, 0x35, 0x2C, 0x39, 0x32, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x2E, 0x36, 0x29,
			0x3B, 0x6F, 0x75, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0x2D, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x3A, 0x33, 0x70, 0x78, 0x3B, 0x7D, 0x2E, 0x70, 0x72,
			0x6F, 0x6D, 0x70, 0x74, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x32, 0x34, 0x70, 0x78, 0x20, 0x61, 0x75, 0x74, 0x6F, 0x20, 0x30, 0x20,
			0x61, 0x75, 0x74, 0x6F, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x6D, 0x69, 0x6E, 0x28, 0x39, 0x30, 0x30, 0x70, 0x78,
			0x2C, 0x39, 0x32, 0x76, 0x77, 0x29, 0x3B, 0x6C, 0x69, 0x6E, 0x65, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x2E, 0x37, 0x35, 0x3B,
			0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x6D, 0x69, 0x73, 0x74, 0x79, 0x72, 0x6F, 0x73, 0x65, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D, 0x73, 0x69, 0x7A,
			0x65, 0x3A, 0x63, 0x6C, 0x61, 0x6D, 0x70, 0x28, 0x31, 0x39, 0x70, 0x78, 0x2C, 0x32, 0x2E, 0x31, 0x76, 0x77, 0x2C, 0x32, 0x34, 0x70, 0x78, 0x29,
			0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x77, 0x72, 0x61, 0x70, 0x3A, 0x70, 0x72, 0x65, 0x74, 0x74, 0x79, 0x3B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x69,
			0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62, 0x61, 0x63,
			0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x2E, 0x33, 0x35, 0x73, 0x20, 0x65, 0x61,
			0x73, 0x65, 0x2C, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x3B, 0x7D, 0x66, 0x6F, 0x6F,
			0x74, 0x65, 0x72, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x70, 0x3A, 0x61, 0x75, 0x74, 0x6F, 0x3B, 0x70, 0x61, 0x64, 0x64,
			0x69, 0x6E, 0x67, 0x3A, 0x31, 0x34, 0x70, 0x78, 0x20, 0x31, 0x32, 0x70, 0x78, 0x20, 0x33, 0x30, 0x70, 0x78, 0x20, 0x31, 0x32, 0x70, 0x78, 0x3B,
			0x74, 0x65, 0x78, 0x74, 0x2D, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x3A, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A,
			0x23, 0x63, 0x62, 0x64, 0x32, 0x65, 0x61, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x31, 0x38, 0x70, 0x78, 0x3B, 0x66,
			0x6F, 0x6E, 0x74, 0x2D, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x36, 0x30, 0x30, 0x3B, 0x7D, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x20, 0x61,
			0x7B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x23, 0x63, 0x62, 0x64, 0x32, 0x65, 0x61, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x64, 0x65, 0x63, 0x6F,
			0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2D, 0x62, 0x6F, 0x74, 0x74, 0x6F,
			0x6D, 0x3A, 0x31, 0x70, 0x78, 0x20, 0x64, 0x61, 0x73, 0x68, 0x65, 0x64, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x32, 0x30, 0x33, 0x2C, 0x32, 0x31,
			0x30, 0x2C, 0x32, 0x33, 0x34, 0x2C, 0x2E, 0x34, 0x35, 0x29, 0x3B, 0x7D, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x20, 0x61, 0x3A, 0x68, 0x6F, 0x76,
			0x65, 0x72, 0x7B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x62, 0x75, 0x72, 0x6C, 0x79, 0x77, 0x6F, 0x6F, 0x64, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65,
			0x72, 0x2D, 0x62, 0x6F, 0x74, 0x74, 0x6F, 0x6D, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x72, 0x67, 0x62, 0x61, 0x28, 0x32, 0x32, 0x32, 0x2C,
			0x31, 0x38, 0x34, 0x2C, 0x31, 0x33, 0x35, 0x2C, 0x2E, 0x37, 0x29, 0x3B, 0x7D, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x3E, 0x64, 0x69, 0x76, 0x3A,
			0x6C, 0x61, 0x73, 0x74, 0x2D, 0x63, 0x68, 0x69, 0x6C, 0x64, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x70, 0x3A, 0x32, 0x34,
			0x70, 0x78, 0x3B, 0x7D, 0x2E, 0x62, 0x6F, 0x74, 0x74, 0x6F, 0x6D, 0x2D, 0x73, 0x65, 0x70, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74,
			0x6F, 0x70, 0x3A, 0x35, 0x36, 0x70, 0x78, 0x3B, 0x7D, 0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74,
			0x68, 0x3A, 0x35, 0x32, 0x30, 0x70, 0x78, 0x29, 0x7B, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20, 0x68, 0x31, 0x7B, 0x74, 0x72, 0x61, 0x6E, 0x73,
			0x66, 0x6F, 0x72, 0x6D, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x58, 0x28, 0x2D, 0x35, 0x70, 0x78, 0x29, 0x3B, 0x7D, 0x7D,
			0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x35, 0x32, 0x30, 0x70, 0x78, 0x29, 0x7B,
			0x2E, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x7B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x6A, 0x75,
			0x73, 0x74, 0x69, 0x66, 0x79, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3A, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x7D, 0x2E, 0x62,
			0x74, 0x6E, 0x7B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x69, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x2D, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x61,
			0x6C, 0x69, 0x67, 0x6E, 0x2D, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x3A, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x6A, 0x75, 0x73, 0x74, 0x69, 0x66,
			0x79, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3A, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x61,
			0x75, 0x74, 0x6F, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x35, 0x34, 0x76, 0x77, 0x3B, 0x70, 0x61, 0x64, 0x64, 0x69,
			0x6E, 0x67, 0x3A, 0x37, 0x70, 0x78, 0x20, 0x31, 0x33, 0x70, 0x78, 0x3B, 0x77, 0x68, 0x69, 0x74, 0x65, 0x2D, 0x73, 0x70, 0x61, 0x63, 0x65, 0x3A,
			0x6E, 0x6F, 0x77, 0x72, 0x61, 0x70, 0x3B, 0x7D, 0x7D, 0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x73, 0x2D,
			0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x64, 0x2D, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x29, 0x7B, 0x2A,
			0x7B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x20, 0x21, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74,
			0x61, 0x6E, 0x74, 0x3B, 0x61, 0x6E, 0x69, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x20, 0x21, 0x69, 0x6D, 0x70, 0x6F,
			0x72, 0x74, 0x61, 0x6E, 0x74, 0x3B, 0x7D, 0x7D, 0x2E, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x63, 0x6F,
			0x6C, 0x6F, 0x72, 0x3A, 0x74, 0x68, 0x69, 0x73, 0x74, 0x6C, 0x65, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69,
			0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x3B, 0x2D, 0x77, 0x65, 0x62, 0x6B, 0x69, 0x74, 0x2D, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72,
			0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x63, 0x6C, 0x69, 0x70, 0x3A, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67,
			0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2D, 0x63, 0x6F, 0x6C,
			0x6F, 0x72, 0x3A, 0x79, 0x65, 0x6C, 0x6C, 0x6F, 0x77, 0x3B, 0x62, 0x6F, 0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x30, 0x20, 0x30,
			0x20, 0x30, 0x20, 0x31, 0x2E, 0x35, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x31, 0x32, 0x2C, 0x30, 0x2C,
			0x2E, 0x39, 0x35, 0x29, 0x2C, 0x30, 0x20, 0x30, 0x20, 0x33, 0x36, 0x70, 0x78, 0x20, 0x31, 0x34, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28,
			0x32, 0x35, 0x35, 0x2C, 0x32, 0x31, 0x32, 0x2C, 0x30, 0x2C, 0x2E, 0x36, 0x29, 0x2C, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x73, 0x68, 0x61, 0x64,
			0x6F, 0x77, 0x29, 0x3B, 0x7D, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20, 0x2E, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x7B, 0x64, 0x69, 0x73,
			0x70, 0x6C, 0x61, 0x79, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x3B, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x6C, 0x61,
			0x74, 0x69, 0x76, 0x65, 0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x70, 0x78, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x3A, 0x70, 0x75, 0x72, 0x70, 0x6C, 0x65, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x3A, 0x30, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69,
			0x6E, 0x3A, 0x30, 0x3B, 0x6C, 0x65, 0x66, 0x74, 0x3A, 0x35, 0x30, 0x25, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x63, 0x61, 0x6C, 0x63, 0x28,
			0x31, 0x30, 0x30, 0x76, 0x77, 0x20, 0x2B, 0x20, 0x38, 0x70, 0x78, 0x29, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x6C, 0x65, 0x66, 0x74,
			0x3A, 0x63, 0x61, 0x6C, 0x63, 0x28, 0x2D, 0x35, 0x30, 0x76, 0x77, 0x20, 0x2D, 0x20, 0x34, 0x70, 0x78, 0x29, 0x3B, 0x7D, 0x68, 0x65, 0x61, 0x64,
			0x65, 0x72, 0x20, 0x2E, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x3A, 0x3A, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x7B, 0x63, 0x6F, 0x6E, 0x74,
			0x65, 0x6E, 0x74, 0x3A, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x3B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x6E, 0x6F, 0x6E, 0x65,
			0x3B, 0x7D, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x3A, 0x3A, 0x61, 0x66, 0x74, 0x65, 0x72, 0x7B, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3A,
			0x6E, 0x6F, 0x6E, 0x65, 0x20, 0x21, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x61, 0x6E, 0x74, 0x3B, 0x7D, 0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28,
			0x6F, 0x72, 0x69, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x6C, 0x61, 0x6E, 0x64, 0x73, 0x63, 0x61, 0x70, 0x65, 0x29, 0x20, 0x61,
			0x6E, 0x64, 0x20, 0x28, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x39, 0x30, 0x30, 0x70, 0x78, 0x29, 0x7B, 0x2E, 0x69, 0x6D,
			0x61, 0x67, 0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x7B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x36, 0x34, 0x76, 0x77,
			0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x39, 0x38, 0x64, 0x76, 0x68, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67,
			0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x6D, 0x67, 0x7B, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2D, 0x66, 0x69, 0x74, 0x3A, 0x63,
			0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74,
			0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x7D, 0x7D, 0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28, 0x6D, 0x69, 0x6E, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68,
			0x3A, 0x39, 0x30, 0x31, 0x70, 0x78, 0x29, 0x7B, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x7B, 0x6D, 0x61, 0x78,
			0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x37, 0x30, 0x76, 0x68, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66, 0x72, 0x61,
			0x6D, 0x65, 0x20, 0x69, 0x6D, 0x67, 0x7B, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2D, 0x66, 0x69, 0x74, 0x3A, 0x63, 0x6F, 0x76, 0x65, 0x72, 0x3B,
			0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x35, 0x30, 0x25, 0x20, 0x34, 0x30, 0x25, 0x3B,
			0x7D, 0x7D, 0x3C, 0x2F, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3E, 0x3C, 0x2F, 0x68, 0x65, 0x61, 0x64, 0x3E, 0x3C, 0x62, 0x6F, 0x64, 0x79, 0x3E, 0x3C,
			0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x3E, 0x3C, 0x68, 0x31, 0x3E, 0x49, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77,
			0x20, 0x26, 0x61, 0x6D, 0x70, 0x3B, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x3C, 0x2F, 0x68, 0x31, 0x3E, 0x3C,
			0x64, 0x69, 0x76, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x22, 0x20, 0x72, 0x6F, 0x6C, 0x65,
			0x3D, 0x22, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x22, 0x20, 0x61, 0x72, 0x69, 0x61, 0x2D, 0x68, 0x69, 0x64, 0x64, 0x65, 0x6E,
			0x3D, 0x22, 0x74, 0x72, 0x75, 0x65, 0x22, 0x3E, 0x3C, 0x2F, 0x64, 0x69, 0x76, 0x3E, 0x3C, 0x2F, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x3E, 0x3C,
			0x6D, 0x61, 0x69, 0x6E, 0x3E, 0x3C, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x69, 0x6D, 0x61, 0x67,
			0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x22, 0x3E, 0x3C, 0x61, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x25, 0x25, 0x55, 0x52, 0x4C, 0x25, 
			0x25, 0x22, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x3D, 0x22, 0x5F, 0x62, 0x6C, 0x61, 0x6E, 0x6B, 0x22, 0x20, 0x72, 0x65, 0x6C, 0x3D, 0x22,
			0x6E, 0x6F, 0x6F, 0x70, 0x65, 0x6E, 0x65, 0x72, 0x20, 0x6E, 0x6F, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x72, 0x22, 0x3E, 0x3C, 0x69, 0x6D,
			0x67, 0x20, 0x73, 0x72, 0x63, 0x3D, 0x22, 0x24, 0x7B, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x7D, 0x22, 0x20, 0x61, 0x6C, 0x74, 0x3D, 0x22, 0x69, 0x6D,
			0x67, 0x22, 0x3E, 0x3C, 0x2F, 0x61, 0x3E, 0x3C, 0x2F, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x3E, 0x3C, 0x64, 0x69, 0x76, 0x20, 0x63, 0x6C, 0x61,
			0x73, 0x73, 0x3D, 0x22, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x22, 0x3E, 0x3C, 0x62, 0x75, 0x74, 0x74, 0x6F, 0x6E, 0x20, 0x69, 0x64, 0x3D,
			0x22, 0x63, 0x6F, 0x70, 0x79, 0x42, 0x74, 0x6E, 0x22, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x62, 0x74, 0x6E, 0x22, 0x20, 0x74, 0x79,
			0x70, 0x65, 0x3D, 0x22, 0x62, 0x75, 0x74, 0x74, 0x6F, 0x6E, 0x22, 0x20, 0x61, 0x72, 0x69, 0x61, 0x2D, 0x6C, 0x69, 0x76, 0x65, 0x3D, 0x22, 0x70,
			0x6F, 0x6C, 0x69, 0x74, 0x65, 0x22, 0x3E, 0x43, 0x6F, 0x70, 0x79, 0x20, 0x50, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x3C, 0x2F, 0x62, 0x75, 0x74, 0x74,
			0x6F, 0x6E, 0x3E, 0x3C, 0x2F, 0x64, 0x69, 0x76, 0x3E, 0x3C, 0x70, 0x20, 0x69, 0x64, 0x3D, 0x22, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x54, 0x65,
			0x78, 0x74, 0x22, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x22, 0x3E, 0x25, 0x25, 0x50, 0x52, 0x4F,
			0x4D, 0x50, 0x54, 0x25, 0x25, 0x3C, 0x2F, 0x70, 0x3E, 0x3C, 0x2F, 0x6D, 0x61, 0x69, 0x6E, 0x3E, 0x3C, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x3E,
			0x3C, 0x64, 0x69, 0x76, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x20, 0x62, 0x6F, 0x74, 0x74,
			0x6F, 0x6D, 0x2D, 0x73, 0x65, 0x70, 0x22, 0x20, 0x72, 0x6F, 0x6C, 0x65, 0x3D, 0x22, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x22,
			0x20, 0x61, 0x72, 0x69, 0x61, 0x2D, 0x68, 0x69, 0x64, 0x64, 0x65, 0x6E, 0x3D, 0x22, 0x74, 0x72, 0x75, 0x65, 0x22, 0x3E, 0x3C, 0x2F, 0x64, 0x69,
			0x76, 0x3E, 0x3C, 0x64, 0x69, 0x76, 0x3E, 0x3C, 0x61, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F,
			0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x43, 0x6C, 0x65, 0x61, 0x73, 0x62, 0x79, 0x43, 0x6F, 0x64, 0x65, 0x2F, 0x69,
			0x6D, 0x67, 0x70, 0x72, 0x6D, 0x74, 0x22, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x3D, 0x22, 0x5F, 0x62, 0x6C, 0x61, 0x6E, 0x6B, 0x22, 0x20,
			0x72, 0x65, 0x6C, 0x3D, 0x22, 0x6E, 0x6F, 0x6F, 0x70, 0x65, 0x6E, 0x65, 0x72, 0x22, 0x3E, 0x69, 0x6D, 0x67, 0x70, 0x72, 0x6D, 0x74, 0x20, 0x76,
			0x31, 0x2E, 0x33, 0x3C, 0x2F, 0x61, 0x3E, 0x3C, 0x2F, 0x64, 0x69, 0x76, 0x3E, 0x3C, 0x2F, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x3E, 0x60, 0x3B,
			0x28, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x28, 0x29, 0x7B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x62, 0x74, 0x6E, 0x3D, 0x64, 0x6F,
			0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x67, 0x65, 0x74, 0x45, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x42, 0x79, 0x49, 0x64, 0x28, 0x22, 0x63,
			0x6F, 0x70, 0x79, 0x42, 0x74, 0x6E, 0x22, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x74, 0x65, 0x78, 0x74, 0x45, 0x6C, 0x3D, 0x64, 0x6F,
			0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x67, 0x65, 0x74, 0x45, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x42, 0x79, 0x49, 0x64, 0x28, 0x22, 0x70,
			0x72, 0x6F, 0x6D, 0x70, 0x74, 0x54, 0x65, 0x78, 0x74, 0x22, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E,
			0x61, 0x6C, 0x3D, 0x62, 0x74, 0x6E, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74,
			0x20, 0x69, 0x6D, 0x67, 0x45, 0x6C, 0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x71, 0x75, 0x65, 0x72, 0x79, 0x53, 0x65, 0x6C,
			0x65, 0x63, 0x74, 0x6F, 0x72, 0x28, 0x22, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x6D, 0x67, 0x22,
			0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x28, 0x74, 0x79, 0x70, 0x65, 0x6F, 0x66, 0x20, 0x77, 0x69,
			0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x3D, 0x3D, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x22, 0x26, 0x26, 0x77,
			0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x2E, 0x74, 0x72, 0x69, 0x6D, 0x28, 0x29, 0x29, 0x3F, 0x77, 0x69, 0x6E, 0x64,
			0x6F, 0x77, 0x2E, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x2E, 0x74, 0x72, 0x69, 0x6D, 0x28, 0x29, 0x3A, 0x6E, 0x65, 0x77, 0x20, 0x55, 0x52, 0x4C, 0x53,
			0x65, 0x61, 0x72, 0x63, 0x68, 0x50, 0x61, 0x72, 0x61, 0x6D, 0x73, 0x28, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x73, 0x65, 0x61,
			0x72, 0x63, 0x68, 0x29, 0x2E, 0x67, 0x65, 0x74, 0x28, 0x22, 0x69, 0x6D, 0x67, 0x22, 0x29, 0x3B, 0x69, 0x66, 0x28, 0x66, 0x6E, 0x61, 0x6D, 0x65,
			0x29, 0x7B, 0x69, 0x6D, 0x67, 0x45, 0x6C, 0x2E, 0x73, 0x72, 0x63, 0x3D, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x3B, 0x7D, 0x61, 0x73, 0x79, 0x6E, 0x63,
			0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x54, 0x6F, 0x43, 0x6C, 0x69, 0x70, 0x62, 0x6F, 0x61, 0x72,
			0x64, 0x28, 0x74, 0x65, 0x78, 0x74, 0x29, 0x7B, 0x74, 0x72, 0x79, 0x7B, 0x69, 0x66, 0x28, 0x6E, 0x61, 0x76, 0x69, 0x67, 0x61, 0x74, 0x6F, 0x72,
			0x2E, 0x63, 0x6C, 0x69, 0x70, 0x62, 0x6F, 0x61, 0x72, 0x64, 0x26, 0x26, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x69, 0x73, 0x53, 0x65, 0x63,
			0x75, 0x72, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x29, 0x7B, 0x61, 0x77, 0x61, 0x69, 0x74, 0x20, 0x6E, 0x61, 0x76, 0x69, 0x67, 0x61,
			0x74, 0x6F, 0x72, 0x2E, 0x63, 0x6C, 0x69, 0x70, 0x62, 0x6F, 0x61, 0x72, 0x64, 0x2E, 0x77, 0x72, 0x69, 0x74, 0x65, 0x54, 0x65, 0x78, 0x74, 0x28,
			0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x72, 0x75, 0x65, 0x3B, 0x7D, 0x7D, 0x63, 0x61, 0x74, 0x63,
			0x68, 0x28, 0x65, 0x29, 0x7B, 0x7D, 0x74, 0x72, 0x79, 0x7B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x74, 0x61, 0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D,
			0x65, 0x6E, 0x74, 0x2E, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x28, 0x22, 0x74, 0x65, 0x78, 0x74, 0x61,
			0x72, 0x65, 0x61, 0x22, 0x29, 0x3B, 0x74, 0x61, 0x2E, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x3D, 0x74, 0x65, 0x78, 0x74, 0x3B, 0x74, 0x61, 0x2E, 0x73,
			0x65, 0x74, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x28, 0x22, 0x72, 0x65, 0x61, 0x64, 0x6F, 0x6E, 0x6C, 0x79, 0x22, 0x2C, 0x22,
			0x22, 0x29, 0x3B, 0x74, 0x61, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3D, 0x22, 0x66, 0x69,
			0x78, 0x65, 0x64, 0x22, 0x3B, 0x74, 0x61, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x74, 0x6F, 0x70, 0x3D, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22,
			0x3B, 0x74, 0x61, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x6C, 0x65, 0x66, 0x74, 0x3D, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22, 0x3B, 0x74, 0x61,
			0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x6F, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x3D, 0x22, 0x30, 0x22, 0x3B, 0x64, 0x6F, 0x63, 0x75, 0x6D,
			0x65, 0x6E, 0x74, 0x2E, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x43, 0x68, 0x69, 0x6C, 0x64, 0x28, 0x74, 0x61, 0x29,
			0x3B, 0x74, 0x61, 0x2E, 0x66, 0x6F, 0x63, 0x75, 0x73, 0x28, 0x29, 0x3B, 0x74, 0x61, 0x2E, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x28, 0x29, 0x3B,
			0x74, 0x61, 0x2E, 0x73, 0x65, 0x74, 0x53, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x52, 0x61, 0x6E, 0x67, 0x65, 0x28, 0x30, 0x2C, 0x74,
			0x61, 0x2E, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x6F, 0x6B,
			0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x65, 0x78, 0x65, 0x63, 0x43, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x28, 0x22, 0x63,
			0x6F, 0x70, 0x79, 0x22, 0x29, 0x3B, 0x74, 0x61, 0x2E, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x28, 0x29, 0x3B, 0x69, 0x66, 0x28, 0x6F, 0x6B, 0x29,
			0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x72, 0x75, 0x65, 0x3B, 0x7D, 0x63, 0x61, 0x74, 0x63, 0x68, 0x28, 0x65, 0x29, 0x7B, 0x7D, 0x74,
			0x72, 0x79, 0x7B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x73, 0x70, 0x61, 0x6E, 0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x63,
			0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x28, 0x22, 0x73, 0x70, 0x61, 0x6E, 0x22, 0x29, 0x3B, 0x73, 0x70, 0x61,
			0x6E, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x74, 0x65, 0x78, 0x74, 0x3B, 0x73, 0x70, 0x61, 0x6E, 0x2E,
			0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x45, 0x64, 0x69, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x3D, 0x22, 0x74, 0x72, 0x75, 0x65, 0x22, 0x3B, 0x73,
			0x70, 0x61, 0x6E, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3D, 0x22, 0x66, 0x69, 0x78, 0x65,
			0x64, 0x22, 0x3B, 0x73, 0x70, 0x61, 0x6E, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x74, 0x6F, 0x70, 0x3D, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22,
			0x3B, 0x73, 0x70, 0x61, 0x6E, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x6C, 0x65, 0x66, 0x74, 0x3D, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22, 0x3B,
			0x73, 0x70, 0x61, 0x6E, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x6F, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x3D, 0x22, 0x30, 0x22, 0x3B,
			0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x43, 0x68, 0x69, 0x6C,
			0x64, 0x28, 0x73, 0x70, 0x61, 0x6E, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x3D, 0x64, 0x6F, 0x63, 0x75,
			0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x61, 0x6E, 0x67, 0x65, 0x28, 0x29, 0x3B, 0x72, 0x61, 0x6E, 0x67, 0x65,
			0x2E, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x4E, 0x6F, 0x64, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x73, 0x28, 0x73, 0x70, 0x61, 0x6E,
			0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x73, 0x65, 0x6C, 0x3D, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x67, 0x65, 0x74, 0x53, 0x65,
			0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x28, 0x29, 0x3B, 0x73, 0x65, 0x6C, 0x2E, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x41, 0x6C, 0x6C, 0x52,
			0x61, 0x6E, 0x67, 0x65, 0x73, 0x28, 0x29, 0x3B, 0x73, 0x65, 0x6C, 0x2E, 0x61, 0x64, 0x64, 0x52, 0x61, 0x6E, 0x67, 0x65, 0x28, 0x72, 0x61, 0x6E,
			0x67, 0x65, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x6F, 0x6B, 0x32, 0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x65,
			0x78, 0x65, 0x63, 0x43, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x28, 0x22, 0x63, 0x6F, 0x70, 0x79, 0x22, 0x29, 0x3B, 0x73, 0x65, 0x6C, 0x2E, 0x72,
			0x65, 0x6D, 0x6F, 0x76, 0x65, 0x41, 0x6C, 0x6C, 0x52, 0x61, 0x6E, 0x67, 0x65, 0x73, 0x28, 0x29, 0x3B, 0x73, 0x70, 0x61, 0x6E, 0x2E, 0x72, 0x65,
			0x6D, 0x6F, 0x76, 0x65, 0x28, 0x29, 0x3B, 0x69, 0x66, 0x28, 0x6F, 0x6B, 0x32, 0x29, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x72, 0x75,
			0x65, 0x3B, 0x7D, 0x63, 0x61, 0x74, 0x63, 0x68, 0x28, 0x65, 0x29, 0x7B, 0x7D, 0x74, 0x72, 0x79, 0x7B, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E,
			0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x28, 0x22, 0x43, 0x6F, 0x70, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x74, 0x65, 0x78, 0x74, 0x3A, 0x22,
			0x2C, 0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x7D, 0x63, 0x61, 0x74, 0x63, 0x68, 0x28, 0x5F, 0x29, 0x7B, 0x7D, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E,
			0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x3B, 0x7D, 0x62, 0x74, 0x6E, 0x2E, 0x61, 0x64, 0x64, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4C, 0x69, 0x73, 0x74,
			0x65, 0x6E, 0x65, 0x72, 0x28, 0x22, 0x63, 0x6C, 0x69, 0x63, 0x6B, 0x22, 0x2C, 0x61, 0x73, 0x79, 0x6E, 0x63, 0x28, 0x29, 0x3D, 0x3E, 0x7B, 0x63,
			0x6F, 0x6E, 0x73, 0x74, 0x20, 0x74, 0x65, 0x78, 0x74, 0x3D, 0x74, 0x65, 0x78, 0x74, 0x45, 0x6C, 0x2E, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x54, 0x65,
			0x78, 0x74, 0x2E, 0x74, 0x72, 0x69, 0x6D, 0x28, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x6F, 0x6B, 0x3D, 0x61, 0x77, 0x61, 0x69, 0x74,
			0x20, 0x63, 0x6F, 0x70, 0x79, 0x54, 0x6F, 0x43, 0x6C, 0x69, 0x70, 0x62, 0x6F, 0x61, 0x72, 0x64, 0x28, 0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x62,
			0x74, 0x6E, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x6F, 0x6B, 0x3F, 0x22, 0x43, 0x6F, 0x70, 0x69, 0x65,
			0x64, 0x21, 0x22, 0x3A, 0x22, 0x43, 0x6F, 0x70, 0x79, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x22, 0x3B, 0x62, 0x74, 0x6E, 0x2E, 0x64, 0x69,
			0x73, 0x61, 0x62, 0x6C, 0x65, 0x64, 0x3D, 0x74, 0x72, 0x75, 0x65, 0x3B, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x28, 0x28, 
			0x29, 0x3D, 0x3E, 0x7B, 0x62, 0x74, 0x6E, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x6F, 0x72, 0x69, 0x67,
			0x69, 0x6E, 0x61, 0x6C, 0x3B, 0x62, 0x74, 0x6E, 0x2E, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x64, 0x3D, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x3B,
			0x7D, 0x2C, 0x31, 0x36, 0x30, 0x30, 0x29, 0x3B, 0x7D, 0x29, 0x3B, 0x20, 0x7D, 0x29, 0x28, 0x29, 0x7D, 0x29, 0x3B, 0x3C, 0x2F, 0x73, 0x63, 0x72,
			0x69, 0x70, 0x74, 0x3E, 0x3C, 0x2F, 0x62, 0x6F, 0x64, 0x79, 0x3E, 0x3C, 0x2F, 0x68, 0x74, 0x6D, 0x6C, 0x3E, 0x3C, 0x73, 0x63, 0x72, 0x69, 0x70,
			0x74, 0x3E, 0x3C, 0x2F, 0x62, 0x6F, 0x64, 0x79, 0x3E, 0x3C, 0x2F, 0x68, 0x74, 0x6D, 0x6C, 0x3E
		};
		
		// For X-Twitter, Mastodon, Tumblr & Flickr.
		constexpr std::size_t
			PROFILE_VEC_INTERNAL_DIFF 	 = 38ULL,	// Bytes we don't count as part of internal profile size.
			PROFILE_VEC_MAIN_DIFF 	 	 = 22ULL,	// Bytes we don't count as part of profile size.
			PROFILE_VEC_INSERT_INDEX 	 = 0x14ULL, // Insert location within segment_vec for the color profile (profile_vec).
			PROFILE_VEC_SIZE_FIELD_INDEX = 0x28ULL, // Start index location for internal size field of the image color profile.(Max four bytes, only two used).
			SEGMENT_VEC_SIZE_FIELD_INDEX = 0x16ULL, // Start index location for size field of the main color profile. (Max two bytes).
			SEGMENT_VEC_INSERT_INDEX 	 = 0xE3ULL,
			SEGMENT_VEC_START_INDEX 	 = 0x17ULL;
		
		Byte bits = 16;
		
		if (args.option == Option::None) { 
			segment_vec.insert(segment_vec.begin() + PROFILE_VEC_INSERT_INDEX, profile_vec.begin(), profile_vec.end());
		} else {		
			bluesky_vec.insert(bluesky_vec.begin() + SEGMENT_VEC_INSERT_INDEX, segment_vec.begin() + SEGMENT_VEC_START_INDEX, segment_vec.end());
			segment_vec.swap(bluesky_vec);
		}

		vBytes().swap(bluesky_vec);
		vBytes().swap(profile_vec);
		constexpr auto PROMPT_INSERT_MARKER = std::to_array<Byte>({'%','%','P','R','O','M','P','T','%','%'});
		constexpr auto URL_INSERT_MARKER = std::to_array<Byte>({'%','%','U','R','L','%','%'});
	
		auto 
			prompt_pos = searchSig(segment_vec, std::span<const Byte>(PROMPT_INSERT_MARKER)),
			url_pos    = searchSig(segment_vec, std::span<const Byte>(URL_INSERT_MARKER));

		segment_vec.insert(segment_vec.begin() + *prompt_pos, utf8_prompt.begin(), utf8_prompt.end());
		segment_vec.erase(segment_vec.begin()  + *prompt_pos + utf8_prompt.size(), segment_vec.begin() + *prompt_pos + utf8_prompt.size() + PROMPT_INSERT_MARKER.size());
		
		segment_vec.insert(segment_vec.begin() + *url_pos, utf8_url.begin(), utf8_url.end());
		segment_vec.erase(segment_vec.begin()  + *url_pos + utf8_url.size(), segment_vec.begin() + *url_pos + utf8_url.size() + URL_INSERT_MARKER.size());
		
		std::string().swap(utf8_prompt);
		std::string().swap(utf8_url);
		
		constexpr std::size_t
			MAX_SEGMENT_SIZE 	  = 65534ULL,     // ~64KB
			TWITTER_SEGMENT_LIMIT = 10ULL * 1024; // X-Twitter 10KB.
		
		std::size_t segment_size = segment_vec.size();
		
		if (args.option == Option::None && segment_size > TWITTER_SEGMENT_LIMIT) {
			std::wcerr << "\n\nWarning: Data content exceeds the maximum segment size limit for X-Twitter.\n\t Image will not be compatible for posting on that platform.\n";
		}
		
		if (segment_size > MAX_SEGMENT_SIZE) {
			throw std::runtime_error("File Size Error: Data content size exceeds the maximum segment limit.");
		}
		
		#ifdef _WIN32
			if (old_stdin_mode  != -1) (void)_setmode(_fileno(stdin),  old_stdin_mode);
    		if (old_stdout_mode != -1) (void)_setmode(_fileno(stdout), old_stdout_mode);		
		#endif
	
		if (args.option == Option::Bluesky) {
			segment_size -= 4; // For Bluesky segment size, don't count the JPG ID + APP ID "FFD8FFE1" (4 bytes).
		
			constexpr std::size_t 
				EXIF_SIZE_FIELD_INDEX 	     = 0x04ULL,  
				EXIF_ARTIST_SIZE_FIELD_INDEX = 0x4AULL;  
				
			const std::size_t EXIF_ARTIST_SIZE = segment_size - 0x8C;
				
			updateValue(segment_vec, EXIF_SIZE_FIELD_INDEX , segment_size, bits);
		
			bits = 32;
			
			updateValue(segment_vec, EXIF_ARTIST_SIZE_FIELD_INDEX, EXIF_ARTIST_SIZE, bits); 
		} else {
			// Update color profile segment size field (FFE2xxxx)
			updateValue(segment_vec, SEGMENT_VEC_SIZE_FIELD_INDEX, segment_size - PROFILE_VEC_MAIN_DIFF, bits);
			// Update internal color profile size field
			updateValue(segment_vec, PROFILE_VEC_SIZE_FIELD_INDEX, segment_size - PROFILE_VEC_INTERNAL_DIFF, bits);
		}	

		jpg_vec.insert(jpg_vec.begin(), segment_vec.begin(), segment_vec.end());
		vBytes().swap(segment_vec); 

		jpg_vec_size = jpg_vec.size();

		std::random_device rd;
    	std::mt19937 gen(rd());
    	std::uniform_int_distribution<> dist(10000, 99999);
	
		const std::string OUTPUT_FILENAME = "imgprmt_" + std::to_string(dist(gen)) + ".jpg";

		std::ofstream write_file_fs(OUTPUT_FILENAME, std::ios::binary);
		if (!write_file_fs) {
			throw std::runtime_error("Write Error: Unable to write to file. Make sure you have WRITE permissions for this location.");
		}

		write_file_fs.write(reinterpret_cast<const char*>(jpg_vec.data()), jpg_vec_size);
		
		vBytes().swap(jpg_vec);
		std::cout << "\nSaved \"prompt-embedded\" JPG image: " << OUTPUT_FILENAME << " (" << jpg_vec_size << " bytes).\n\n";
		return 0;
	}
	catch (const std::runtime_error& e) {
    	std::cerr << "\n" << e.what() << "\n\n";
    	return 1;
    }
}
