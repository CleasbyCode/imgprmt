//  imgprmt v1.2 (Linux / Windows CLI Edition). Created by Nicholas Cleasby (@CleasbyCode) 19/05/2023

// Compile program (Linux):

// $ sudo apt-get install libturbojpeg0-dev

// $ chmod +x compile_imgprmt.sh
// $ ./compile_imgprmt.sh
	
// $ Compilation successful. Executable 'imgprmt' created.
// $ sudo cp imgprmt /usr/bin
// $ imgprmt

#ifdef _WIN32
	#define NOMINMAX
    #include <windows.h>

    #include "windows/libjpeg-turbo/include/turbojpeg.h"
    // This software is based in part on the work of the Independent JPEG Group.
	// Copyright (C) 2009-2024 D. R. Commander. All Rights Reserved.
	// Copyright (C) 2015 Viktor Szathmáry. All Rights Reserved.
	// https://github.com/libjpeg-turbo/libjpeg-turbo
    	
   	#include <fcntl.h>
    #include <io.h>
    #include <cstdio>
#else
	#include <clocale> 
  	#include <locale>   
    #include <cwchar>
    #include <termios.h>
	#include <unistd.h>
    #include <turbojpeg.h>
#endif

#include <string>
#include <string_view>
#include <cstring>
#include <cctype>
#include <cstddef>
#include <cstdlib>
#include <cstdint>
#include <initializer_list>
#include <optional>
#include <span>
#include <stdexcept>
#include <iostream>
#include <fstream>
#include <array>
#include <vector>
#include <filesystem>
#include <algorithm>
#include <random>

namespace fs = std::filesystem;

static void display_info() {
	std::cout << R"(
Imgprmt v1.2 (CLI Edition).
Created by Nicholas Cleasby (@CleasbyCode) 25/05/2023.

imgprmt is a command-line tool for Linux and Windows that
embeds image text prompts into JPG images. 
		
It outputs a unique JPG-HTML polyglot file, combining image, prompt text & html.

Share the resulting image on compatible social media platforms like:-
		
X-Twitter, Tumblr, Mastodon, Pixelfed, Flickr & *Bluesky.
		
The embedded prompt is preserved for anyone who downloads the image.

To view the stored prompt locally, rename the image extension to ".htm" and open
it in a web browser to display the basic webpage.

For a convenient alternative to downloading & compiling the CLI source code, use the imgprmt Web App:-
		
https://cleasbycode.co.uk/imgprmt/app/
________________________
Compile & run (Linux)
________________________
		
  $ sudo apt-get install libturbojpeg0-dev

  $ chmod +x compile_imgprmt.sh
  $ ./compile_imgprmt.sh

  Compilation successful. Executable 'imgprmt' created.

  $ sudo cp imgprmt /usr/bin
  $ imgprmt
________________________
Usage
________________________

  imgprmt [-b] <jpg_image>
  imgprmt --info

With the default command-line arguments without any option(s), 
the embedded image can be posted on X-Twitter, Tumblr, Mastodon Pixelfed & Flickr.
		
The default prompt limit is 57140 bytes (minus URL address length).
		
X-Twitter, for compatibility reasons, is limited to 1845 bytes (minus URL address length).
Considerably smaller than the default size, but should be adequate for most prompts.

If you intend to share your prompt-embedded image on Bluesky,
you must first add the -b option to the command-line arguments:-

$ imgprmt -b my_image.jpg

Secondly, to post the image on Bluesky, you will need to use the bsky_post.py script, 
located in the repo src folder.

To run this script, you need Python3 and the 'requests' and 'bs4' (BeautifulSoup)
Python packages installed.

An app-password is also required for the Python script, which you can create 
from your Bluesky account: https://bsky.app/settings/app-passwords

Here are some basic usage examples for the bsky_post.py Python script:

Standard image post to your profile/account.

$ python3 bsky_post.py --handle you.bsky.social --password xxxx-xxxx-xxxx-xxxx 
--image your_image.jpg --alt-text "alt-text here [optional]" "standard post text here [required]"

If you want to post multiple images (Max. 4):

$ python3 bsky_post.py --handle you.bsky.social --password xxxx-xxxx-xxxx-xxxx 
--image img1.jpg --image img2.jpg --alt-text "alt_here" "standard post text..."

If you want to post an image as a reply to another thread:

$ python3 bsky_post.py --handle you.bsky.social --password xxxx-xxxx-xxxx-xxxx 
--image your_image.jpg --alt-text "alt_here" 
--reply-to https://bsky.app/profile/someone.bsky.social/post/8m2tgw6cgi23i 
"standard post text..."

Images created with the -b option can also be posted on Tumblr (bsky_post.py script not required). 
Image file size upload limit for Bluesky is ~1MB.

)";
}

enum class Option : unsigned char { None, Bluesky };

struct program_args {
    Option option{Option::None};
    fs::path image_file_path;

    static std::optional<program_args> parse(int argc, char** argv) {
    	using std::string_view;

        auto arg = [&](int i) -> string_view {
            return (i >= 0 && i < argc) ? string_view(argv[i]) : string_view{};
        };

        const std::string prog  = fs::path(argv[0]).filename().string();
        const std::string USAGE = "Usage: " + prog + " [-b] <jpg_image>\n\t\b" + prog + " --info";

        auto die = [&]() -> void { throw std::runtime_error(USAGE); };

        if (argc < 2 || argc > 3) die();

        if (argc == 2 && arg(1) == "--info") {
            display_info();
            return std::nullopt;  
        }

        program_args out{};
        int i = 1;

        if (arg(i) == "-b") {
            out.option = Option::Bluesky;
            ++i;
        }

        out.image_file_path = fs::path(arg(i));
        return out;
    }
};

// searchSig function searches a byte vector (uint8_t) for a fixed byte pattern and returns the offset of the first match, or std::nullopt if there’s no match.
// It uses std::search on v.begin().. v.end() with the pattern given by sig.begin().. sig.end(). 
	
// The std::span<const uint8_t> parameter lets you pass anything contiguous - std::array, C-array, another std::vector, or a subrange, without copying. 
// If std::search returns v.end(), the function maps that to std::nullopt; otherwise it converts the iterator difference to a size_t index.
static std::optional<size_t> searchSig(const std::vector<uint8_t>& v, std::span<const uint8_t> sig) {
	auto it = std::search(v.begin(), v.end(), sig.begin(), sig.end());
    if (it == v.end()) return std::nullopt;
    return static_cast<size_t>(it - v.begin());
}

// First search for an EXIF segment, if found search for an Orientation tag.
// Returns 1..8 if found and passed to normalize_orientation, or std::nullopt if no EXIF/Orientation.
static std::optional<uint16_t> exif_orientation(const std::vector<uint8_t>& jpg) {
	const uint8_t APP1[] = {0xFF, 0xE1};
    auto app1 = searchSig(jpg, std::span<const uint8_t>(APP1, 2));
    if (!app1) return std::nullopt;

    size_t p = *app1;
    if (p + 4 > jpg.size()) return std::nullopt;

    uint16_t len = (static_cast<uint16_t>(jpg[p+2]) << 8) | jpg[p+3];
    size_t exif_end = p + 2 + len;            
    if (exif_end > jpg.size()) return std::nullopt;

    size_t exif_start = p + 4;
    if (exif_start + 6 > exif_end) return std::nullopt;
    if (std::memcmp(&jpg[exif_start], "Exif\0\0", 6) != 0) return std::nullopt;

    size_t tiff = exif_start + 6;
    if (tiff + 8 > exif_end) return std::nullopt;

    bool le = false;
    if (jpg[tiff] == 'I' && jpg[tiff+1] == 'I') le = true;
    else if (jpg[tiff] == 'M' && jpg[tiff+1] == 'M') le = false;
    else return std::nullopt;

    auto rd16 = [&](size_t off) -> uint16_t {
		if (off + 1 >= exif_end) return 0;
        return le ? (uint16_t)(jpg[off] | (jpg[off+1] << 8)) : (uint16_t)((jpg[off] << 8) | jpg[off+1]);
    };
    auto rd32 = [&](size_t off) -> uint32_t {
        if (off + 3 >= exif_end) return 0;
        return le ? (uint32_t)(jpg[off] | (jpg[off+1] << 8) | (jpg[off+2] << 16) | (jpg[off+3] << 24)) : (uint32_t)((jpg[off] << 24) | (jpg[off+1] << 16) | (jpg[off+2] << 8) | jpg[off+3]);
    };

    if (rd16(tiff + 2) != 0x002A) return std::nullopt;
    uint32_t ifd0_off = rd32(tiff + 4);
    size_t ifd = tiff + ifd0_off;
    if (ifd + 2 > exif_end) return std::nullopt;

    uint16_t count = rd16(ifd);
    ifd += 2;
    for (uint16_t i = 0; i < count; ++i) {
    	size_t entry = ifd + i * 12;
        if (entry + 12 > exif_end) return std::nullopt;
        uint16_t tag = rd16(entry + 0);
        if (tag == 0x0112) {
            return rd16(entry + 8); // 1..8 usually. 
        }
    }
    return std::nullopt;
}

static void rotate_rgb_180(std::vector<uint8_t>& rgb, int w, int h) {
    const int stride = w * 3;
    for (int y = 0; y < h / 2; ++y) {
		int opp = h - 1 - y;
        for (int x = 0; x < w; ++x) {
        	for (int c = 0; c < 3; ++c)
            	std::swap(rgb[y*stride + x*3 + c], rgb[opp*stride + (w-1-x)*3 + c]);
        }
    }
    if (h % 2 == 1) {
        int y = h/2;
        for (int x = 0; x < w/2; ++x)
            for (int c = 0; c < 3; ++c)
                std::swap(rgb[y*stride + x*3 + c], rgb[y*stride + (w-1-x)*3 + c]);
    }
}

static void rotate_rgb_90cw(std::vector<uint8_t>& rgb, int& w, int& h) {
    std::vector<uint8_t> out(static_cast<size_t>(w) * static_cast<size_t>(h) * 3);
    int nw = h;
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            int nx = h - 1 - y, ny = x;
            for (int c = 0; c < 3; ++c)
                out[(static_cast<size_t>(ny) * nw + nx) * 3 + c] =
                    rgb[(static_cast<size_t>(y) * w + x) * 3 + c];
        }
    }
    rgb.swap(out);
    std::swap(w, h);
}

static void rotate_rgb_270cw(std::vector<uint8_t>& rgb, int& w, int& h) {
    std::vector<uint8_t> out(static_cast<size_t>(w) * static_cast<size_t>(h) * 3);
    int nw = h;
    for (int y = 0; y < h; ++y) {
        for (int x = 0; x < w; ++x) {
            int nx = y, ny = w - 1 - x;
            for (int c = 0; c < 3; ++c)
                out[(static_cast<size_t>(ny) * nw + nx) * 3 + c] =
                    rgb[(static_cast<size_t>(y) * w + x) * 3 + c];
        }
    }
    rgb.swap(out);
    std::swap(w, h);
}

// If exif_orientation found an Orientation tag, use normalize_orientation 
// and its above helpers to normalize the pixels, so that we can later safely remove
// the EXIF segment from the cover image and have correct orientation with viewers.
// Minimal mapper: handle 3,6,8 (most common). Add flips (2,4,5,7)...
static void normalize_orientation(std::vector<uint8_t>& rgb, int& w, int& h, int ori) {
    switch (ori) {
        case 3: rotate_rgb_180(rgb, w, h); break;
        case 6: rotate_rgb_90cw(rgb, w, h); break;
        case 8: rotate_rgb_270cw(rgb, w, h); break;
        default: /* 1 or unsupported -> do nothing */ break;
    }
}

static void update_value(std::vector<uint8_t>& vec, uint32_t insert_index, uint32_t NEW_VALUE, uint8_t bits) {
	while (bits) {
		vec[insert_index++] = (NEW_VALUE >> (bits -= 8)) & 0xFF; 
    }
}

static bool has_valid_filename(const fs::path& p) {
	if (p.empty()) {
    	return false;
	}		
    
    std::string filename = p.filename().string();
    if (filename.empty()) {
    	return false;
    }

    auto valid_char = [](unsigned char c) {
    	return std::isalnum(c) || c == '.' || c == '-' || c == '_' || c == '@' || c == '%';
 	};

    return std::all_of(filename.begin(), filename.end(), valid_char);
}

static bool has_file_extension(const fs::path& p, std::initializer_list<const char*> exts) {
	auto e = p.extension().string();
    std::transform(e.begin(), e.end(), e.begin(), [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
    for (const char* cand : exts) {
    	std::string c = cand;
        std::transform(c.begin(), c.end(), c.begin(), [](unsigned char x){ return static_cast<char>(std::tolower(x)); });
        if (e == c) return true;
    }
    return false;
}

// Sanitizes user-supplied (wide) text so it’s safe to drop into an HTML context while still allowing line breaks. 
// Everything else goes through a switch that HTML-escapes the dangerous characters & < > " ' \`` into their entities (&, <, >, ", ', ``&#96;``), preventing HTML/JS injection;
// Any other character is copied as-is. 
static void replace_problem_chars(std::wstring& s) {
    auto starts_with = [](const std::wstring& t, size_t pos, const std::wstring& needle) -> bool {
        return pos + needle.size() <= t.size() && t.compare(pos, needle.size(), needle) == 0;
    };

    std::wstring out;
    out.reserve(s.size()); 

    for (size_t i = 0; i < s.size(); ++i) {
        wchar_t c = s[i];

        if (c == L'<') {
            if (starts_with(s, i, L"<br>"))   { out += L"<br>";   i += 3; continue; }
            if (starts_with(s, i, L"<br/>"))  { out += L"<br/>";  i += 4; continue; }
            if (starts_with(s, i, L"<br />")) { out += L"<br />"; i += 5; continue; }
        }

        switch (c) {
            case L'&':  out += L"&amp;";  break;
            case L'<':  out += L"&lt;";   break;
            case L'>':  out += L"&gt;";   break;
            case L'"':  out += L"&quot;"; break;
            case L'\'': out += L"&#39;";  break;   
            case L'`':  out += L"&#96;";  break;

            case L'\r':
                if (i + 1 < s.size() && s[i + 1] == L'\n') ++i; 
                out += L"<br>";
                break;
            case L'\n':
                out += L"<br>";
                break;
	    	case L'\\': 
	    		out.push_back(L'\\');
    			break;
            default:
                out.push_back(c);
                break;
        }
    }
    s.swap(out);
}

// Try to set a UTF-8 C locale; keep C++ locale in sync if it works. (Linux).
static bool force_utf8_locale() {
	if (std::setlocale(LC_ALL, "C.UTF-8") || std::setlocale(LC_ALL, "en_US.UTF-8") || std::setlocale(LC_ALL, "UTF-8")) {
    	try {
            	std::locale::global(std::locale(""));
        } catch (...) {
            	// If this throws, we still have the C locale set to UTF-8,
            	// so wide→multibyte functions will be OK; streams may remain default.
        }
        return true;
    }
    return false;
}

// Converts a UTF-16/UTF-32 wstring to a UTF-8 string, using the right API on each platform.

// Windows: WideCharToMultiByte is the canonical way to encode UTF-16 to UTF-8. The first call asks for the required buffer size (passing nullptr as the output pointer), 
// which returns a count including the terminating NUL. The code allocates a std::string of size-1 (so the result has no trailing NUL) and calls the function again to actually write the bytes.
// If either call fails, it throws. It also passes WC_ERR_INVALID_CHARS as a flag to reject lone surrogates.

// On Linux, wcsrtombs converts from the current C locale’s wide encoding to multibyte (UTF-8). It’s used in the standard two-pass pattern: first call with nullptr to get the length,
// then allocate and call again to do the conversion. If the input contains an unconvertible sequence under the current locale, wcsrtombs returns (size_t)-1 and the code throws.
static std::string convert_string(const std::wstring& wide) {
	#ifdef _WIN32
    	if (wide.empty()) return {};
    	int size = WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, wide.c_str(), -1, nullptr, 0, nullptr, nullptr);

    	if (size <= 0) throw std::runtime_error("WideCharToMultiByte failed.");

    	std::string converted_string(size - 1, 0); 
    	WideCharToMultiByte(CP_UTF8, 0, wide.c_str(), -1, converted_string.data(), size, nullptr, nullptr);
    	return converted_string;
	#else
    	std::mbstate_t state{};
    	const wchar_t* src = wide.data();
    	size_t len = std::wcsrtombs(nullptr, &src, 0, &state);
    	if (len == static_cast<size_t>(-1)) throw std::runtime_error("Conversion to UTF-8 failed.");

    	std::string converted_string(len, 0);
    	src = wide.data(); 
    	std::wcsrtombs(converted_string.data(), &src, len, &state);
    	return converted_string;
	#endif
}

// This should provide larger console input for Linux. Default is just 4095 chars.
// Temporarily disables canonical input mode so you can read an arbitrarily long line from a TTY without the ~4 KB line buffer limit. 
// TermiosGuard grabs the current terminal settings in its constructor (tcgetattr), makes a copy, clears ICANON (non-canonical mode),
// sets VMIN=1/VTIME=0 so reads return as soon as one byte is available, and applies the change with tcsetattr.
// It records active=true only if the change succeeded. 
// When the guard goes out of scope, the destructor restores the original settings, guaranteeing cleanup even on exceptions (RAII).

// read_long_line_from_tty() simply instantiates TermiosGuard (activating the temporary mode for the duration of the function) 
// and then pulls characters from std::wcin with get() until it sees a newline, appending each wchar_t to a std::wstring.
#ifdef __unix__
	namespace {  
		struct TermiosGuard {
    		termios old{};
    		bool active = false;
    		TermiosGuard() {
        		if (::isatty(STDIN_FILENO)) {
            		if (::tcgetattr(STDIN_FILENO, &old) == 0) {
                		termios raw = old;
                		raw.c_lflag &= ~ICANON;
                		raw.c_cc[VMIN]  = 1;           
                		raw.c_cc[VTIME] = 0;
                		if (::tcsetattr(STDIN_FILENO, TCSAFLUSH, &raw) == 0) {
                    		active = true;
                		}
            		}
        		}
    		}
    		~TermiosGuard() {
        		if (active) {
            		::tcsetattr(STDIN_FILENO, TCSAFLUSH, &old);
        		}
    		}
		};
	} 
	static std::wstring read_long_line_from_tty() {
		TermiosGuard guard;  
    	std::wstring s;
    	wchar_t ch;
    	while (std::wcin.get(ch)) {
        	if (ch == L'\n') break;
        	s.push_back(ch);
    	}
    	return s;
	}
#endif

// Validate URL.
namespace {

	static bool is_dec(char c) noexcept { return c >= '0' && c <= '9'; }
	static bool is_hex(char c) noexcept {
    	unsigned char u = static_cast<unsigned char>(c);
    	return std::isxdigit(u) != 0;
	}
	
	static bool valid_pct(const std::string& s, std::size_t i) noexcept {
    	return i + 2 < s.size() && is_hex(s[i+1]) && is_hex(s[i+2]);
	}

	static bool valid_ipv4(const std::string& s) noexcept {
    	int dots = 0, val = 0, digits = 0;
    	for (char c : s) {
        	if (c == '.') {
            	if (digits == 0 || val > 255) return false;
            		++dots; val = 0; digits = 0;
        	} else if (is_dec(c)) {
				val = val * 10 + (c - '0');
            	if (val > 255) return false;
            		++digits;
        	} else {
            	return false;
        	}
    	}
    	if (digits == 0 || val > 255) return false;
    	return dots == 3;
	}	

	static bool valid_dns_label(const std::string& lbl) noexcept {
    	if (lbl.empty() || lbl.size() > 63) return false;
    	auto alnum = [](unsigned char c){ return std::isalnum(c) != 0; };
    	if (!alnum(lbl.front()) || !alnum(lbl.back())) return false;
    	for (unsigned char c : lbl)
        if (!(alnum(c) || c == '-')) return false;
    	return true;
	}

	static bool valid_hostname_ascii(const std::string& host) noexcept {
    	if (host.empty() || host.size() > 253) return false;
    	if (host.find("..") != std::string::npos) return false;
    	if (host.back() == '.') return false;
    
    	bool all_digits_or_dot = true;
    	for (unsigned char c : host) {
        	if (!(std::isalnum(c) || c == '-' || c == '.')) return false;
        	if (!(std::isdigit(c) || c == '.')) all_digits_or_dot = false;
    	}
    	if (all_digits_or_dot && valid_ipv4(host)) return true;

    	std::size_t start = 0;
    	while (true) {
        	std::size_t dot = host.find('.', start);
        	std::string lbl = host.substr(start, (dot == std::string::npos) ? std::string::npos : dot - start);
        	if (!valid_dns_label(lbl)) return false;
        	if (dot == std::string::npos) break;
        	start = dot + 1;
    	}
    	return true;
	}

	static bool valid_path_query_ascii(const std::string& s, std::string* err) {
    	for (std::size_t i = 0; i < s.size(); ++i) {
        	unsigned char c = static_cast<unsigned char>(s[i]);
        	if (c < 0x20 || c == 0x7F) { if (err) *err = "Control char in path/query"; return false; }
        	if (c == '#') { if (err) *err = "Fragment ('#') not allowed"; return false; }
        	if (c == '%') {
            	if (!valid_pct(s, i)) { if (err) *err = "Bad percent-encoding"; return false; }
            	i += 2;
            	continue;
        	}
        	if (!(std::isalnum(c) || c=='-'||c=='_'||c=='.'||c=='~' ||
				c==':'||c=='/'||c=='?'||c=='@'||c=='!'||c=='$'||c=='&'||
              		c=='\''||c=='('||c==')'||c=='*'||c=='+'||c==','||c==';'||c=='=')) {
            			if (err) *err = "Illegal character in path/query";
            			return false;
        	}
    	}
    	return true;
	}
}

static bool validate_url_link(const std::string& url, std::string* err = nullptr) {
	auto bad = [&](const char* e){ if (err) *err = e; return false; };
	
 	constexpr char kScheme[] = "https://";
 	
    for (unsigned char c : url)
    	if (c < 0x20 || c == 0x7F) return bad("Control/whitespace not allowed");
    std::size_t pos = sizeof(kScheme) - 1;
    std::size_t slash = url.find('/', pos);
    std::string authority = url.substr(pos, (slash == std::string::npos) ? std::string::npos : slash - pos);
    	
    if (authority.empty()) return bad("Missing host");
    if (authority.find('@') != std::string::npos) return bad("Credentials not allowed");

   	std::string host, port_str;
    std::size_t colon = authority.rfind(':');
    	
    if (colon != std::string::npos) {
    	host = authority.substr(0, colon);
        port_str = authority.substr(colon + 1);
        if (port_str.empty()) return bad("Empty port");
        unsigned long port = 0;
        for (char c : port_str) {
        	if (!is_dec(c)) return bad("Port must be digits");
            port = port * 10 + (c - '0');
            if (port > 65535UL) return bad("Port out of range");
        }
        if (port == 0) return bad("Port out of range");
    } else {
        host = authority;
    }

    if (!valid_hostname_ascii(host)) return bad("Invalid host");
    if (slash == std::string::npos) return true;

    return valid_path_query_ascii(url.substr(slash), err);
}

static void validate_url_link_core(const std::string& url) {
	std::string err;
    if (!validate_url_link(url, &err)) {
    	throw std::runtime_error(std::string("Link Error: ") + (err.empty() ? "Invalid URL" : err));
    }
}
//--------------

int main(int argc, char** argv) {
	try {
		auto args_opt = program_args::parse(argc, argv);
        if (!args_opt) return 0; 
        	       
      	program_args args = *args_opt;   
		
		if (!fs::exists(args.image_file_path)) {
        	throw std::runtime_error("Image File Error: File not found.");
    	}
			
		if (!has_valid_filename(args.image_file_path)) {
    		throw std::runtime_error("Invalid Input Error: Unsupported characters in filename arguments.");
		}

		if (!has_file_extension(args.image_file_path, {".jpg", ".jpeg", ".jfif"})) {
        	throw std::runtime_error("File Type Error: Invalid image extension. Only expecting \".jpg\", \".jpeg\", or \".jfif\".");
    	}
    			
		std::ifstream image_file_ifs(args.image_file_path, std::ios::binary);
        	
    	if (!image_file_ifs) {
    		throw std::runtime_error("Read File Error: Unable to read image file. Check the filename and try again.");
   		}

		uintmax_t image_file_size = fs::file_size(args.image_file_path);

    	constexpr uint8_t MINIMUM_IMAGE_SIZE = 134;

    	if (MINIMUM_IMAGE_SIZE > image_file_size) {
        	throw std::runtime_error("Image File Error: Invalid file size.");
    	}
    	
    	constexpr uint32_t 
    		MAX_IMAGE_SIZE_BEFORE_ENCODE  	= 8 * 1024 * 1024,	// 8 MB.
			MAX_IMAGE_SIZE_AFTER_ENCODE		= 4 * 1024 * 1024,	// 4 MB.
    		MAX_IMAGE_SIZE_BLUESKY 			= 912 * 1024;		// 912 KB.
    		
    	if (image_file_size > MAX_IMAGE_SIZE_BEFORE_ENCODE) {
			throw std::runtime_error("Image File Error: Cover image file exceeds maximum size limit.");
		}
    		
		std::vector<uint8_t> image_file_vec(image_file_size);
	
		image_file_ifs.read(reinterpret_cast<char*>(image_file_vec.data()), image_file_size);
		image_file_ifs.close();
	
		// Make sure JPG cover image has both "Start Of Image" & "End Of Image" markers.
		// Also, remove any trailing data after EOI marker.
		constexpr uint8_t 
			SOI0 = 0xFF, 
			SOI1 = 0xD8,
   			EOI0 = 0xFF, 
   			EOI1 = 0xD9;

	    if (!(image_file_vec[0] == SOI0 && image_file_vec[1] == SOI1)) {
        	throw std::runtime_error("Image File Error: Missing SOI marker.");
    	}

    	const std::array<uint8_t,2> EOI{EOI0, EOI1};
		
    	auto last_eoi = std::find_end(image_file_vec.begin() + 2, image_file_vec.end(), EOI.begin(), EOI.end());
		
    	if (last_eoi == image_file_vec.end()) {
        	throw std::runtime_error("Image File Error: Missing EOI marker.");
    	}
	
    	auto after_eoi = last_eoi + 2;
    	if (after_eoi != image_file_vec.end()) {
        	image_file_vec.erase(after_eoi, image_file_vec.end());
    	}

		/*
		To improve compatibility, default re-encode image.
		The following code takes the JPG cover image already loaded into image_file_vec, decodes it with libjpeg-turbo, then re-encodes it with different settings
		depending on argument option settings. It starts by creating a decompressor (tjInitDecompress) and reading the JPG header (tjDecompressHeader3) to get 
		image width & height, chroma subsampling, and colorspace; Failure throws with a readable error.
			
		It allocates an RGB buffer of width * height * 3 bytes and decompresses the JPG into that buffer via tjDecompress2.
			
		Call the exif_orientation function to first check for an EXIF segment, then search it for an Orientation tag. 
		If found, use normalize_orientation and its helpers to normalize the pixels, so that when we later remove the EXIF segment, 
		viewers should still dislpay the image with correct orientation.
			
		For re-encode, it chooses a quality (85 for Bluesky option; 97 for anything else), a subsampling mode (space-saving 4:2:0 for Bluesky; full-quality 4:4:4 for anything else),
		flags: progressive JPGs default, and a DCT speed/quality tradeoff where high quality uses TJFLAG_FASTDCT (faster and fine at ≥90) and lower quality (Bluesky) 
		uses TJFLAG_ACCURATEDCT (slower, slightly more precise). 
			
		The new, re-encoded image is stored in a temporary vector before it is swapped into vector image_file_vec, 
		replacing the old cover image. Temporary vectors are cleared to free memory. 
		*/
		tjhandle decompressor = tjInitDecompress();
		if (!decompressor) throw std::runtime_error("tjInitDecompress() failed.");

		int 
			width = 0, 
			height = 0, 
			jpegSubsamp = 0, 
			jpegColorspace = 0;
		
		if (tjDecompressHeader3(decompressor, image_file_vec.data(), (unsigned long)image_file_vec.size(), &width, &height, &jpegSubsamp, &jpegColorspace) != 0) {
    		tjDestroy(decompressor);
    		throw std::runtime_error(std::string("tjDecompressHeader3: ") + tjGetErrorStr());
		}

		std::vector<uint8_t> decoded_image_vec((size_t)width * (size_t)height * 3);
		if (tjDecompress2(decompressor, image_file_vec.data(), (unsigned long)image_file_vec.size(), decoded_image_vec.data(), width, 0, height, TJPF_RGB, 0) != 0) {
    		tjDestroy(decompressor);
    		throw std::runtime_error(std::string("tjDecompress2: ") + tjGetErrorStr());
		}
			
		auto ori = exif_orientation(image_file_vec);
		if (ori && *ori != 1) {
    		normalize_orientation(decoded_image_vec, width, height, *ori);
		}
			
		tjDestroy(decompressor);

		const bool isBluesky = (args.option == Option::Bluesky);
		const int JPG_QUALITY_VAL = isBluesky ? 85 : 97;

		const int subsamp = isBluesky ? TJSAMP_420 : TJSAMP_444;
		int flags = 0;
		if (!isBluesky) flags |= TJFLAG_PROGRESSIVE; 
		
		flags |= (JPG_QUALITY_VAL >= 90 ? TJFLAG_FASTDCT : TJFLAG_ACCURATEDCT);

		tjhandle compressor = tjInitCompress();
		if (!compressor) throw std::runtime_error("tjInitCompress() failed.");

		uint8_t* jpegBuf = nullptr;
		unsigned long jpegSize = 0;

		if (tjCompress2(compressor, decoded_image_vec.data(), width, 0, height, TJPF_RGB, &jpegBuf, &jpegSize, subsamp, JPG_QUALITY_VAL, flags) != 0) {
    		tjDestroy(compressor);
    		throw std::runtime_error(std::string("tjCompress2: ") + tjGetErrorStr());
		}	
		tjDestroy(compressor);

		std::vector<uint8_t> output_image_vec(jpegBuf, jpegBuf + jpegSize);
		tjFree(jpegBuf);

		image_file_vec.swap(output_image_vec);
		
		std::vector<uint8_t>().swap(output_image_vec);
		std::vector<uint8_t>().swap(decoded_image_vec);
		// ------------
			
		// Save some space. Remove superfluous segments from cover image. (EXIF, ICC color profile, etc).
		auto eraseAppSegment = [](std::vector<uint8_t>& v, std::span<const uint8_t> sig) {
    		auto pos = searchSig(v, sig);
    		if (!pos) return;
    		if (*pos + 3 >= v.size()) return;

    		uint16_t block_len = (static_cast<uint16_t>(v[*pos + 2]) << 8) | static_cast<uint16_t>(v[*pos + 3]);
    		size_t erase_end = *pos + 2 + block_len;
    		if (erase_end > v.size()) return;

    		v.erase(v.begin() + *pos, v.begin() + erase_end);
		};
			
		constexpr std::array<uint8_t, 2>
			APP1_EXIF_SIG { 0xFF, 0xE1 }, 
			APP2_ICC_SIG  { 0xFF, 0xE2 }; 

		constexpr std::array<uint8_t, 4>
			DQT1_SIG { 0xFF, 0xDB, 0x00, 0x43 },	// Define Quantization Tables SIG.
			DQT2_SIG { 0xFF, 0xDB, 0x00, 0x84 };
				
		eraseAppSegment(image_file_vec, std::span<const uint8_t>(APP1_EXIF_SIG));
		eraseAppSegment(image_file_vec, std::span<const uint8_t>(APP2_ICC_SIG));

    	auto dqt1 = searchSig(image_file_vec, std::span<const uint8_t>(DQT1_SIG));
    	auto dqt2 = searchSig(image_file_vec, std::span<const uint8_t>(DQT2_SIG));

		if (!dqt1 && !dqt2) {
    		throw std::runtime_error("Image File Error: No DQT segment found (corrupt or unsupported JPEG).");
		}

		const size_t NPOS = static_cast<size_t>(-1);
		size_t dqt_pos = std::min(dqt1.value_or(NPOS), dqt2.value_or(NPOS));
		image_file_vec.erase(image_file_vec.begin(), image_file_vec.begin() + static_cast<std::ptrdiff_t>(dqt_pos));
		// ------------
		
		image_file_size = image_file_vec.size();  // Get updated cover image size after image re-encode, removing superfluous segments & trailing data.
		
		if (image_file_size > MAX_IMAGE_SIZE_AFTER_ENCODE) {
			throw std::runtime_error("Image File Error: Image exceeds maximum size limit.");
		}
			
		if (isBluesky && image_file_size > MAX_IMAGE_SIZE_BLUESKY) {
			throw std::runtime_error("Image File Error: Image exceeds maximum size limit for Bluesky.");
		}
		
		std::cout << "\n*** imgprmt v1.2 ***\n";

		#ifdef _WIN32
			// Try to give std::wcin a larger buffer
			constexpr int WIN_BUFFER_SIZE = 65535;
   			static std::vector<wchar_t> win_inbuf(WIN_BUFFER_SIZE);
    		std::wcin.rdbuf()->pubsetbuf(win_inbuf.data(), win_inbuf.size());
			
			// Flushes pending output. Ensures nothing buffered is stuck before switching modes.
   			std::wcout.flush();
   			std::cout.flush();

			// Detects TTY vs pipe. Chooses text mode.
			// TTY ⇒ _O_U16TEXT: the MSVCRT will read/write UTF-16 to/from the Windows console API (best for correct Unicode at the console).
			// Pipe/file ⇒ _O_BINARY: avoids CR/LF translation and lets you control encoding at the byte level (good for piping).
			// Applies the modes and remembers old ones, which are restored later at end of program.
   			bool stdin_is_tty  = (_isatty(_fileno(stdin))  != 0);
  			bool stdout_is_tty = (_isatty(_fileno(stdout)) != 0);
			
    		int desired_in_mode  = stdin_is_tty  ? _O_U16TEXT : _O_BINARY;
    		int desired_out_mode = stdout_is_tty ? _O_U16TEXT : _O_BINARY;

    		int old_stdin_mode  = _setmode(_fileno(stdin),  desired_in_mode);
    		int old_stdout_mode = _setmode(_fileno(stdout), desired_out_mode);
		#else
			if (!force_utf8_locale()) {
        		throw std::runtime_error(
           			"UTF-8 locale is required. Please install/enable a UTF-8 locale "
					"(e.g., C.UTF-8 or en_US.UTF-8) and try again.");
   			}

   			// Imbue wide streams with the (now UTF-8) global locale
    		const std::locale loc("");   // current global
    		std::wcin.imbue(loc);
    		std::wcout.imbue(loc);
    		std::wcerr.imbue(loc);
		#endif
	
		std::wstring
			wprompt,
			wurl;

		constexpr uint32_t 
			URL_MIN_CHARS = 12,
			URL_MAX_CHARS = 200;
			
		std::wcout << L"\nEnter a web address (Your site, social media page, etc).\nFull URL: ";
		std::getline(std::wcin, wurl);
	
		const std::wstring prefix = L"https://";
		
		if (URL_MIN_CHARS > wurl.length() || wurl.substr(0, prefix.length()) != prefix || wurl.length() > URL_MAX_CHARS) {
			throw std::runtime_error("Link Error: URL must start with 'https://', have a minimun length of 12 characters and not exceed 200 characters.");
		}
		
		uint16_t 
			default_max_bytes = static_cast<uint16_t>(57140 - wurl.length()),
			twitter_max_bytes = static_cast<uint16_t>(1845 - wurl.length());
			
		if (args.option == Option::None) { 
			std::wcout << L"\nDefault byte limit: " << default_max_bytes << " | X-Twitter byte limit: " << twitter_max_bytes << ".\n";
		} else {
			std::wcout << L"\nDefault byte limit: " << default_max_bytes << ".\n";
		}
		
		std::wcout << L"\nType or paste in your prompt as one long sentence."; 
		std::wcout << L"\nIf required, add <br> tags to your text for new lines.\n\nPrompt: ";
		#ifdef _WIN32 
			std::getline(std::wcin, wprompt); 
		#else 
			wprompt = read_long_line_from_tty(); 
		#endif

		replace_problem_chars(wprompt);

		std::string utf8_url = convert_string(wurl);
		validate_url_link_core(utf8_url);
		
		std::wstring().swap(wurl);
		
		std::string utf8_prompt = convert_string(wprompt);
		std::wstring().swap(wprompt);
		
		// Color Profile (X-Twitter, Mastodon, Pixelfed, Tumblr & Flickr). The vector is inserted into the main default segment vector.
		std::vector<uint8_t>profile_vec {
			0xFF, 0xE2, 0x00, 0x00, 0x49, 0x43, 0x43, 0x5F, 0x50, 0x52, 0x4F, 0x46, 0x49, 0x4C, 0x45, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x21,
			0x2D, 0x2D, 0x04, 0x20, 0x00, 0x00, 0x6D, 0x6E, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5A, 0x20, 0x07, 0xE5, 0x00, 0x04, 0x00, 0x1B,
			0x00, 0x0A, 0x00, 0x1B, 0x00, 0x00, 0x61, 0x63, 0x73, 0x70, 0x4D, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00, 0x73, 0x61, 0x77, 0x73, 0x63, 0x74,
			0x72, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0xD6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
			0xD3, 0x2D, 0x68, 0x61, 0x6E, 0x64, 0x40, 0x92, 0xFF, 0x1E, 0x67, 0x34, 0xB5, 0x6D, 0x00, 0x1C, 0x4E, 0x36, 0x73, 0x3F, 0x4E, 0x71, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x24, 0x63, 0x70, 0x72, 0x74, 0x00, 0x00,
			0x01, 0x20, 0x00, 0x00, 0x00, 0x22, 0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x01, 0x44, 0x00, 0x00, 0x00, 0x14, 0x63, 0x68, 0x61, 0x64, 0x00, 0x00,
			0x01, 0x58, 0x00, 0x00, 0x00, 0x2C, 0x72, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x01, 0x84, 0x00, 0x00, 0x00, 0x14, 0x67, 0x58, 0x59, 0x5A, 0x00, 0x00,
			0x01, 0x98, 0x00, 0x00, 0x00, 0x14, 0x62, 0x58, 0x59, 0x5A, 0x00, 0x00, 0x01, 0xAC, 0x00, 0x00, 0x00, 0x14, 0x72, 0x54, 0x52, 0x43, 0x00, 0x00,
			0x01, 0xC0, 0x00, 0x00, 0x00, 0x20, 0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00, 0x20, 0x62, 0x54, 0x52, 0x43, 0x00, 0x00,
			0x01, 0xC0, 0x00, 0x00, 0x00, 0x20, 0x6D, 0x6C, 0x75, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x65, 0x6E,
			0x55, 0x53, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x41, 0x00, 0x39, 0x00, 0x38, 0x00, 0x43, 0x6D, 0x6C, 0x75, 0x63, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0C, 0x65, 0x6E, 0x55, 0x53, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x43,
			0x00, 0x43, 0x00, 0x30, 0x00, 0x00, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF6, 0xD6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,
			0xD3, 0x2D, 0x73, 0x66, 0x33, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0C, 0x42, 0x00, 0x00, 0x05, 0xDE, 0xFF, 0xFF, 0xF3, 0x25, 0x00, 0x00,
			0x07, 0x93, 0x00, 0x00, 0xFD, 0x90, 0xFF, 0xFF, 0xFB, 0xA1, 0xFF, 0xFF, 0xFD, 0xA2, 0x00, 0x00, 0x03, 0xDC, 0x00, 0x00, 0xC0, 0x6E, 0x58, 0x59,
			0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x18, 0x00, 0x00, 0x4F, 0xA5, 0x00, 0x00, 0x04, 0xFC, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x34, 0x8D, 0x00, 0x00, 0xA0, 0x2C, 0x00, 0x00, 0x0F, 0x95, 0x58, 0x59, 0x5A, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x26, 0x31, 0x00, 0x00, 0x10, 0x2F, 0x00, 0x00, 0xBE, 0x9C, 0x70, 0x61, 0x72, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02,
			0x33, 0x33, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0E, 0x41
		};
		
		// If option -b selected. This vector contains the basic EXIF segment required for BlueSky. Color profile not supported by BlueSky.
		// Currently without webpage, user's image prompt & URL; which is inserted later. The contents of segment_vec (not including JPG header) is inserted
		// into this vector.
		std::vector<uint8_t>bluesky_vec {
			0xFF, 0xD8, 0xFF, 0xE1, 0x1A, 0xDC, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, 0x4D, 0x4D, 0x00, 0x2A, 0x00, 0x00, 0x00, 0x08, 0x00, 0x06, 0x01, 0x12,
			0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x01, 0x1A, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0xA6, 0x01, 0x1B,
			0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0xAE, 0x01, 0x28, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x01, 0x3B,
			0x00, 0x02, 0x00, 0x00, 0x1A, 0x4F, 0x00, 0x00, 0x00, 0x56, 0x87, 0x69, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0xB6, 0x00, 0x00,
			0x00, 0x00, 0x43, 0x68, 0x61, 0x6E, 0x67, 0x65, 0x20, 0x66, 0x69, 0x6C, 0x65, 0x20, 0x65, 0x78, 0x74, 0x65, 0x6E, 0x73, 0x69, 0x6F, 0x6E, 0x20,
			0x74, 0x6F, 0x20, 0x2E, 0x68, 0x74, 0x6D, 0x20, 0x74, 0x6F, 0x20, 0x76, 0x69, 0x65, 0x77, 0x20, 0x65, 0x6D, 0x62, 0x65, 0x64, 0x64, 0x65, 0x64,
			0x20, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x2F, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F,
			0x6E, 0x2E, 0x20, 0x69, 0x6D, 0x67, 0x70, 0x72, 0x6D, 0x74, 0x20, 0x76, 0x31, 0x2E, 0x32, 0x20, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x20,
			0x62, 0x79, 0x20, 0x4E, 0x69, 0x63, 0x68, 0x6F, 0x6C, 0x61, 0x73, 0x20, 0x43, 0x6C, 0x65, 0x61, 0x73, 0x62, 0x79, 0x20, 0x28, 0x40, 0x43, 0x6C,
			0x65, 0x61, 0x73, 0x62, 0x79, 0x43, 0x6F, 0x64, 0x65, 0x29, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
			0x48, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0xA0, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0xE8, 0xA0, 0x03, 0x00, 0x04, 0x00,
			0x00, 0x00, 0x01, 0x00, 0x00, 0x02, 0xF1, 0x00, 0x00, 0x00, 0x00
		};
		
		// Main segment vector containing JPG header and basic webpage to display user's image prompt. This vector is either inserted into bluesky_vec, if
		// -b option selected (not including JPG header bytes), or profile_vec is inserted into this vector, default (no option selected).
		std::vector<uint8_t>segment_vec {
			0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x48, 0x00, 0x48, 0x00, 0x00, 0x2D, 0x2D, 0x3E, 0x3C,
			0x21, 0x44, 0x4F, 0x43, 0x54, 0x59, 0x50, 0x45, 0x20, 0x68, 0x74, 0x6D, 0x6C, 0x3E, 0x3C, 0x68, 0x74, 0x6D, 0x6C, 0x20, 0x6C, 0x61, 0x6E, 0x67,
			0x3D, 0x22, 0x65, 0x6E, 0x22, 0x3E, 0x3C, 0x68, 0x65, 0x61, 0x64, 0x3E, 0x3C, 0x6D, 0x65, 0x74, 0x61, 0x20, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65,
			0x74, 0x3D, 0x22, 0x75, 0x74, 0x66, 0x2D, 0x38, 0x22, 0x3E, 0x3C, 0x6D, 0x65, 0x74, 0x61, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x22, 0x76, 0x69,
			0x65, 0x77, 0x70, 0x6F, 0x72, 0x74, 0x22, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x22, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3D, 0x64,
			0x65, 0x76, 0x69, 0x63, 0x65, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x2C, 0x20, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x2D, 0x73, 0x63, 0x61,
			0x6C, 0x65, 0x3D, 0x31, 0x22, 0x3E, 0x3C, 0x74, 0x69, 0x74, 0x6C, 0x65, 0x3E, 0x49, 0x4D, 0x47, 0x50, 0x52, 0x4D, 0x54, 0x3C, 0x2F, 0x74, 0x69,
			0x74, 0x6C, 0x65, 0x3E, 0x3C, 0x6D, 0x65, 0x74, 0x61, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x22, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x2D, 0x73, 0x63,
			0x68, 0x65, 0x6D, 0x65, 0x22, 0x20, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x22, 0x64, 0x61, 0x72, 0x6B, 0x20, 0x6C, 0x69, 0x67, 0x68,
			0x74, 0x22, 0x3E, 0x3C, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x72, 0x65, 0x6C, 0x3D, 0x22, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74,
			0x22, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x73, 0x2E, 0x67, 0x6F,
			0x6F, 0x67, 0x6C, 0x65, 0x61, 0x70, 0x69, 0x73, 0x2E, 0x63, 0x6F, 0x6D, 0x22, 0x3E, 0x3C, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x72, 0x65, 0x6C, 0x3D,
			0x22, 0x70, 0x72, 0x65, 0x63, 0x6F, 0x6E, 0x6E, 0x65, 0x63, 0x74, 0x22, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73,
			0x3A, 0x2F, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x73, 0x2E, 0x67, 0x73, 0x74, 0x61, 0x74, 0x69, 0x63, 0x2E, 0x63, 0x6F, 0x6D, 0x22, 0x20, 0x63, 0x72,
			0x6F, 0x73, 0x73, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E, 0x3E, 0x3C, 0x6C, 0x69, 0x6E, 0x6B, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x68, 0x74,
			0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F, 0x66, 0x6F, 0x6E, 0x74, 0x73, 0x2E, 0x67, 0x6F, 0x6F, 0x67, 0x6C, 0x65, 0x61, 0x70, 0x69, 0x73, 0x2E, 0x63,
			0x6F, 0x6D, 0x2F, 0x63, 0x73, 0x73, 0x32, 0x3F, 0x66, 0x61, 0x6D, 0x69, 0x6C, 0x79, 0x3D, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x3A, 0x77, 0x67, 0x68,
			0x74, 0x40, 0x34, 0x30, 0x30, 0x3B, 0x35, 0x30, 0x30, 0x3B, 0x36, 0x30, 0x30, 0x3B, 0x37, 0x30, 0x30, 0x26, 0x66, 0x61, 0x6D, 0x69, 0x6C, 0x79,
			0x3D, 0x50, 0x6C, 0x75, 0x73, 0x2B, 0x4A, 0x61, 0x6B, 0x61, 0x72, 0x74, 0x61, 0x2B, 0x53, 0x61, 0x6E, 0x73, 0x3A, 0x77, 0x67, 0x68, 0x74, 0x40,
			0x34, 0x30, 0x30, 0x3B, 0x36, 0x30, 0x30, 0x26, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3D, 0x73, 0x77, 0x61, 0x70, 0x22, 0x20, 0x72, 0x65,
			0x6C, 0x3D, 0x22, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x73, 0x68, 0x65, 0x65, 0x74, 0x22, 0x3E, 0x3C, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x3E, 0x64,
			0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x61, 0x64, 0x64, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4C, 0x69, 0x73, 0x74, 0x65, 0x6E, 0x65, 0x72,
			0x28, 0x22, 0x44, 0x4F, 0x4D, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x4C, 0x6F, 0x61, 0x64, 0x65, 0x64, 0x22, 0x2C, 0x28, 0x29, 0x3D, 0x3E,
			0x7B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x70, 0x61, 0x74, 0x68, 0x3D, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x6C, 0x6F, 0x63, 0x61, 0x74,
			0x69, 0x6F, 0x6E, 0x2E, 0x70, 0x61, 0x74, 0x68, 0x6E, 0x61, 0x6D, 0x65, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x66, 0x6E, 0x61, 0x6D, 0x65,
			0x3D, 0x70, 0x61, 0x74, 0x68, 0x2E, 0x73, 0x70, 0x6C, 0x69, 0x74, 0x28, 0x22, 0x2F, 0x22, 0x29, 0x2E, 0x70, 0x6F, 0x70, 0x28, 0x29, 0x3B, 0x64,
			0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x48, 0x54, 0x4D, 0x4C, 0x3D, 0x60,
			0x3C, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3E, 0x3A, 0x72, 0x6F, 0x6F, 0x74, 0x7B, 0x2D, 0x2D, 0x62, 0x67, 0x2D, 0x73, 0x74, 0x61, 0x72, 0x74, 0x3A,
			0x23, 0x30, 0x38, 0x31, 0x38, 0x32, 0x30, 0x3B, 0x2D, 0x2D, 0x62, 0x67, 0x2D, 0x65, 0x6E, 0x64, 0x3A, 0x23, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
			0x3B, 0x2D, 0x2D, 0x74, 0x65, 0x78, 0x74, 0x3A, 0x23, 0x65, 0x61, 0x66, 0x30, 0x66, 0x66, 0x3B, 0x2D, 0x2D, 0x6D, 0x75, 0x74, 0x65, 0x64, 0x3A,
			0x23, 0x62, 0x37, 0x63, 0x30, 0x64, 0x36, 0x3B, 0x2D, 0x2D, 0x62, 0x72, 0x61, 0x6E, 0x64, 0x3A, 0x23, 0x38, 0x61, 0x34, 0x63, 0x66, 0x30, 0x3B,
			0x2D, 0x2D, 0x62, 0x72, 0x61, 0x6E, 0x64, 0x2D, 0x32, 0x3A, 0x23, 0x35, 0x35, 0x37, 0x66, 0x64, 0x38, 0x3B, 0x2D, 0x2D, 0x63, 0x61, 0x72, 0x64,
			0x3A, 0x23, 0x30, 0x65, 0x31, 0x66, 0x33, 0x66, 0x3B, 0x2D, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x30, 0x20, 0x31, 0x32, 0x70, 0x78,
			0x20, 0x33, 0x30, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x2E, 0x34, 0x29, 0x2C, 0x30, 0x20, 0x32,
			0x70, 0x78, 0x20, 0x38, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x30, 0x2C, 0x30, 0x2C, 0x30, 0x2C, 0x2E, 0x33, 0x35, 0x29, 0x3B, 0x7D,
			0x68, 0x74, 0x6D, 0x6C, 0x2C, 0x62, 0x6F, 0x64, 0x79, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x30, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D,
			0x66, 0x61, 0x6D, 0x69, 0x6C, 0x79, 0x3A, 0x22, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x22, 0x2C, 0x22, 0x50, 0x6C, 0x75, 0x73, 0x20, 0x4A, 0x61, 0x6B,
			0x61, 0x72, 0x74, 0x61, 0x20, 0x53, 0x61, 0x6E, 0x73, 0x22, 0x2C, 0x22, 0x53, 0x65, 0x67, 0x6F, 0x65, 0x20, 0x55, 0x49, 0x22, 0x2C, 0x73, 0x79,
			0x73, 0x74, 0x65, 0x6D, 0x2D, 0x75, 0x69, 0x2C, 0x2D, 0x61, 0x70, 0x70, 0x6C, 0x65, 0x2D, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2C, 0x52, 0x6F,
			0x62, 0x6F, 0x74, 0x6F, 0x2C, 0x41, 0x72, 0x69, 0x61, 0x6C, 0x2C, 0x73, 0x61, 0x6E, 0x73, 0x2D, 0x73, 0x65, 0x72, 0x69, 0x66, 0x3B, 0x63, 0x6F,
			0x6C, 0x6F, 0x72, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x62, 0x67, 0x2D, 0x65, 0x6E, 0x64, 0x29, 0x3B, 0x62,
			0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x20, 0x21, 0x69, 0x6D,
			0x70, 0x6F, 0x72, 0x74, 0x61, 0x6E, 0x74, 0x3B, 0x6D, 0x69, 0x6E, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x30, 0x30, 0x64, 0x76,
			0x68, 0x3B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x66, 0x6C, 0x65, 0x78, 0x2D, 0x64, 0x69, 0x72, 0x65,
			0x63, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x3B, 0x6F, 0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x2D, 0x78, 0x3A,
			0x68, 0x69, 0x64, 0x64, 0x65, 0x6E, 0x3B, 0x7D, 0x62, 0x6F, 0x64, 0x79, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x30, 0x3B, 0x66, 0x6F,
			0x6E, 0x74, 0x2D, 0x66, 0x61, 0x6D, 0x69, 0x6C, 0x79, 0x3A, 0x22, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x22, 0x2C, 0x22, 0x50, 0x6C, 0x75, 0x73, 0x20,
			0x4A, 0x61, 0x6B, 0x61, 0x72, 0x74, 0x61, 0x20, 0x53, 0x61, 0x6E, 0x73, 0x22, 0x2C, 0x22, 0x53, 0x65, 0x67, 0x6F, 0x65, 0x20, 0x55, 0x49, 0x22,
			0x2C, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x2D, 0x75, 0x69, 0x2C, 0x2D, 0x61, 0x70, 0x70, 0x6C, 0x65, 0x2D, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6D,
			0x2C, 0x52, 0x6F, 0x62, 0x6F, 0x74, 0x6F, 0x2C, 0x41, 0x72, 0x69, 0x61, 0x6C, 0x2C, 0x73, 0x61, 0x6E, 0x73, 0x2D, 0x73, 0x65, 0x72, 0x69, 0x66,
			0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67,
			0x72, 0x6F, 0x75, 0x6E, 0x64, 0x3A, 0x72, 0x61, 0x64, 0x69, 0x61, 0x6C, 0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x32,
			0x30, 0x30, 0x70, 0x78, 0x20, 0x38, 0x30, 0x30, 0x70, 0x78, 0x20, 0x61, 0x74, 0x20, 0x32, 0x30, 0x25, 0x20, 0x2D, 0x31, 0x30, 0x25, 0x2C, 0x23,
			0x30, 0x66, 0x32, 0x62, 0x35, 0x61, 0x20, 0x30, 0x25, 0x2C, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x36, 0x30,
			0x25, 0x29, 0x2C, 0x72, 0x61, 0x64, 0x69, 0x61, 0x6C, 0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x30, 0x30, 0x30, 0x70,
			0x78, 0x20, 0x31, 0x30, 0x30, 0x30, 0x70, 0x78, 0x20, 0x61, 0x74, 0x20, 0x31, 0x32, 0x30, 0x25, 0x20, 0x31, 0x30, 0x25, 0x2C, 0x23, 0x30, 0x61,
			0x31, 0x66, 0x34, 0x35, 0x20, 0x30, 0x25, 0x2C, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x20, 0x35, 0x35, 0x25, 0x29,
			0x2C, 0x6C, 0x69, 0x6E, 0x65, 0x61, 0x72, 0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x38, 0x30, 0x64, 0x65, 0x67, 0x2C,
			0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x62, 0x67, 0x2D, 0x73, 0x74, 0x61, 0x72, 0x74, 0x29, 0x2C, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x62, 0x67,
			0x2D, 0x65, 0x6E, 0x64, 0x29, 0x29, 0x3B, 0x6D, 0x69, 0x6E, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x30, 0x30, 0x64, 0x76, 0x68,
			0x3B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x66, 0x6C, 0x65, 0x78, 0x2D, 0x64, 0x69, 0x72, 0x65, 0x63,
			0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x63, 0x6F, 0x6C, 0x75, 0x6D, 0x6E, 0x3B, 0x7D, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x7B, 0x77, 0x69, 0x64, 0x74,
			0x68, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x3A, 0x32, 0x34, 0x70, 0x78, 0x20, 0x31, 0x36, 0x70, 0x78,
			0x20, 0x38, 0x70, 0x78, 0x20, 0x31, 0x36, 0x70, 0x78, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x3A, 0x63, 0x65, 0x6E,
			0x74, 0x65, 0x72, 0x3B, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3B, 0x7D, 0x68,
			0x31, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x2D, 0x38, 0x70, 0x78, 0x20, 0x30, 0x20, 0x31, 0x36, 0x70, 0x78, 0x20, 0x30, 0x3B, 0x66,
			0x6F, 0x6E, 0x74, 0x2D, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x37, 0x30, 0x30, 0x3B, 0x6C, 0x65, 0x74, 0x74, 0x65, 0x72, 0x2D, 0x73, 0x70,
			0x61, 0x63, 0x69, 0x6E, 0x67, 0x3A, 0x2E, 0x33, 0x70, 0x78, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x63, 0x6C, 0x61,
			0x6D, 0x70, 0x28, 0x32, 0x34, 0x70, 0x78, 0x2C, 0x34, 0x2E, 0x35, 0x76, 0x77, 0x2C, 0x34, 0x36, 0x70, 0x78, 0x29, 0x3B, 0x6C, 0x69, 0x6E, 0x65,
			0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x2E, 0x32, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x77, 0x72, 0x61, 0x70, 0x3A, 0x62, 0x61,
			0x6C, 0x61, 0x6E, 0x63, 0x65, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6C,
			0x69, 0x6E, 0x65, 0x61, 0x72, 0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x39, 0x30, 0x64, 0x65, 0x67, 0x2C, 0x23, 0x66, 0x66,
			0x36, 0x62, 0x36, 0x62, 0x20, 0x30, 0x25, 0x2C, 0x23, 0x66, 0x66, 0x39, 0x66, 0x34, 0x33, 0x20, 0x31, 0x32, 0x25, 0x2C, 0x23, 0x66, 0x66, 0x64,
			0x39, 0x33, 0x64, 0x20, 0x32, 0x34, 0x25, 0x2C, 0x23, 0x34, 0x64, 0x64, 0x34, 0x61, 0x30, 0x20, 0x33, 0x36, 0x25, 0x2C, 0x23, 0x32, 0x62, 0x64,
			0x31, 0x66, 0x63, 0x20, 0x34, 0x38, 0x25, 0x2C, 0x20, 0x23, 0x36, 0x61, 0x61, 0x38, 0x66, 0x66, 0x20, 0x36, 0x30, 0x25, 0x2C, 0x23, 0x37, 0x62,
			0x36, 0x31, 0x66, 0x66, 0x20, 0x37, 0x32, 0x25, 0x2C, 0x23, 0x62, 0x33, 0x36, 0x62, 0x66, 0x66, 0x20, 0x38, 0x34, 0x25, 0x2C, 0x23, 0x66, 0x66,
			0x36, 0x62, 0x64, 0x36, 0x20, 0x31, 0x30, 0x30, 0x25, 0x29, 0x3B, 0x2D, 0x77, 0x65, 0x62, 0x6B, 0x69, 0x74, 0x2D, 0x62, 0x61, 0x63, 0x6B, 0x67,
			0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x63, 0x6C, 0x69, 0x70, 0x3A, 0x74, 0x65, 0x78, 0x74, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x2D, 0x63, 0x6C, 0x69, 0x70, 0x3A, 0x74, 0x65, 0x78, 0x74, 0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73,
			0x70, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x33,
			0x30, 0x30, 0x25, 0x20, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x62, 0x61, 0x63, 0x6B,
			0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x2E, 0x33, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73,
			0x65, 0x2C, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x3B, 0x7D, 0x20, 0x68, 0x31, 0x3A,
			0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F,
			0x6E, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x20, 0x30, 0x3B, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65,
			0x73, 0x73, 0x28, 0x31, 0x2E, 0x30, 0x35, 0x29, 0x3B, 0x7D, 0x68, 0x31, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62, 0x61, 0x63, 0x6B, 0x67,
			0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x20, 0x30, 0x3B, 0x66, 0x69,
			0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x31, 0x2E, 0x30, 0x35, 0x29, 0x3B, 0x7D, 0x68,
			0x31, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74,
			0x69, 0x6F, 0x6E, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x20, 0x30, 0x3B, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74,
			0x6E, 0x65, 0x73, 0x73, 0x28, 0x31, 0x2E, 0x30, 0x35, 0x29, 0x3B, 0x7D, 0x2E, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x7B, 0x64, 0x69, 0x73,
			0x70, 0x6C, 0x61, 0x79, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x3B, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x6C, 0x61,
			0x74, 0x69, 0x76, 0x65, 0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x70, 0x78, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x3A, 0x70, 0x75, 0x72, 0x70, 0x6C, 0x65, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x3A, 0x30, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69,
			0x6E, 0x3A, 0x30, 0x3B, 0x6C, 0x65, 0x66, 0x74, 0x3A, 0x35, 0x30, 0x25, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x63, 0x61, 0x6C, 0x63, 0x28,
			0x31, 0x30, 0x30, 0x76, 0x77, 0x20, 0x2B, 0x20, 0x38, 0x70, 0x78, 0x29, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x6C, 0x65, 0x66, 0x74,
			0x3A, 0x63, 0x61, 0x6C, 0x63, 0x28, 0x2D, 0x35, 0x30, 0x76, 0x77, 0x20, 0x2D, 0x20, 0x34, 0x70, 0x78, 0x29, 0x3B, 0x7D, 0x6D, 0x61, 0x69, 0x6E,
			0x7B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x6D, 0x69,
			0x6E, 0x28, 0x31, 0x30, 0x30, 0x30, 0x70, 0x78, 0x2C, 0x39, 0x32, 0x76, 0x77, 0x29, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x69, 0x6E,
			0x6C, 0x69, 0x6E, 0x65, 0x3A, 0x61, 0x75, 0x74, 0x6F, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x3A, 0x63, 0x65, 0x6E,
			0x74, 0x65, 0x72, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x70, 0x3A, 0x63, 0x6C, 0x61, 0x6D, 0x70, 0x28, 0x30, 0x76, 0x68,
			0x2C, 0x35, 0x2E, 0x35, 0x76, 0x68, 0x2C, 0x38, 0x2E, 0x35, 0x76, 0x68, 0x29, 0x3B, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x3A, 0x30, 0x20,
			0x31, 0x32, 0x70, 0x78, 0x20, 0x36, 0x34, 0x70, 0x78, 0x20, 0x31, 0x32, 0x70, 0x78, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66,
			0x72, 0x61, 0x6D, 0x65, 0x7B, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x6C, 0x61, 0x74, 0x69, 0x76, 0x65, 0x3B, 0x64,
			0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x2D, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x3A,
			0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x6A, 0x75, 0x73, 0x74, 0x69, 0x66, 0x79, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3A, 0x63,
			0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x69, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x3A, 0x61, 0x75, 0x74, 0x6F,
			0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x6D, 0x69, 0x6E, 0x28, 0x35, 0x39, 0x30, 0x2E, 0x34, 0x70, 0x78, 0x2C, 0x36,
			0x32, 0x2E, 0x39, 0x38, 0x32, 0x76, 0x77, 0x29, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x34, 0x35, 0x2E, 0x39,
			0x76, 0x68, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2D, 0x72, 0x61, 0x64, 0x69, 0x75, 0x73, 0x3A, 0x31, 0x38, 0x70, 0x78, 0x3B, 0x62, 0x6F,
			0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x29, 0x3B, 0x6F,
			0x76, 0x65, 0x72, 0x66, 0x6C, 0x6F, 0x77, 0x3A, 0x68, 0x69, 0x64, 0x64, 0x65, 0x6E, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x3A, 0x32, 0x70,
			0x78, 0x20, 0x73, 0x6F, 0x6C, 0x69, 0x64, 0x20, 0x73, 0x69, 0x6C, 0x76, 0x65, 0x72, 0x3B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x6F,
			0x6E, 0x3A, 0x62, 0x6F, 0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62,
			0x6F, 0x72, 0x64, 0x65, 0x72, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x66, 0x69,
			0x6C, 0x74, 0x65, 0x72, 0x20, 0x2E, 0x32, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66, 0x72,
			0x61, 0x6D, 0x65, 0x20, 0x69, 0x6D, 0x67, 0x7B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x3B, 0x6D, 0x61,
			0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A,
			0x31, 0x30, 0x30, 0x25, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x61, 0x75, 0x74, 0x6F, 0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x61,
			0x75, 0x74, 0x6F, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x30, 0x20, 0x61, 0x75, 0x74, 0x6F, 0x3B, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74,
			0x2D, 0x66, 0x69, 0x74, 0x3A, 0x63, 0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x7D, 0x2E, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x7B, 0x6D, 0x61,
			0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x70, 0x3A, 0x32, 0x34, 0x70, 0x78, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x62, 0x6F, 0x74,
			0x74, 0x6F, 0x6D, 0x3A, 0x31, 0x30, 0x70, 0x78, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x7B, 0x2D, 0x2D, 0x70, 0x61, 0x64, 0x2D, 0x79, 0x3A, 0x31,
			0x30, 0x70, 0x78, 0x3B, 0x2D, 0x2D, 0x70, 0x61, 0x64, 0x2D, 0x78, 0x3A, 0x31, 0x38, 0x70, 0x78, 0x3B, 0x2D, 0x2D, 0x72, 0x61, 0x64, 0x69, 0x75,
			0x73, 0x3A, 0x39, 0x39, 0x39, 0x70, 0x78, 0x3B, 0x61, 0x70, 0x70, 0x65, 0x61, 0x72, 0x61, 0x6E, 0x63, 0x65, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x3B,
			0x63, 0x75, 0x72, 0x73, 0x6F, 0x72, 0x3A, 0x70, 0x6F, 0x69, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x75, 0x73, 0x65, 0x72, 0x2D, 0x73, 0x65, 0x6C, 0x65,
			0x63, 0x74, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x3B, 0x70, 0x61, 0x64, 0x64, 0x69, 0x6E, 0x67, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x70, 0x61,
			0x64, 0x2D, 0x79, 0x29, 0x20, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x70, 0x61, 0x64, 0x2D, 0x78, 0x29, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72,
			0x2D, 0x72, 0x61, 0x64, 0x69, 0x75, 0x73, 0x3A, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x72, 0x61, 0x64, 0x69, 0x75, 0x73, 0x29, 0x3B, 0x66, 0x6F,
			0x6E, 0x74, 0x2D, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x34, 0x30, 0x30, 0x3B, 0x6C, 0x65, 0x74, 0x74, 0x65, 0x72, 0x2D, 0x73, 0x70, 0x61,
			0x63, 0x69, 0x6E, 0x67, 0x3A, 0x2E, 0x32, 0x70, 0x78, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x31, 0x35, 0x70, 0x78,
			0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6C, 0x69, 0x6E, 0x65, 0x61, 0x72,
			0x2D, 0x67, 0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x33, 0x35, 0x64, 0x65, 0x67, 0x2C, 0x23, 0x34, 0x65, 0x32, 0x32, 0x61, 0x64,
			0x2C, 0x23, 0x32, 0x62, 0x33, 0x66, 0x38, 0x34, 0x29, 0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x77, 0x68, 0x69, 0x74, 0x65, 0x3B, 0x62, 0x6F,
			0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x30, 0x20, 0x31, 0x30, 0x70, 0x78, 0x20, 0x31, 0x38, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62,
			0x61, 0x28, 0x34, 0x30, 0x2C, 0x35, 0x36, 0x2C, 0x39, 0x34, 0x2C, 0x2E, 0x32, 0x38, 0x29, 0x2C, 0x30, 0x20, 0x34, 0x70, 0x78, 0x20, 0x31, 0x30,
			0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x34, 0x38, 0x2C, 0x32, 0x30, 0x2C, 0x38, 0x38, 0x2C, 0x2E, 0x32, 0x35, 0x29, 0x3B, 0x74, 0x72,
			0x61, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72, 0x6D, 0x20, 0x2E, 0x31, 0x35, 0x73, 0x20,
			0x65, 0x61, 0x73, 0x65, 0x2C, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 0x2E, 0x31, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62, 0x6F,
			0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x20, 0x2E, 0x32, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72,
			0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x2E, 0x32, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x63, 0x6F, 0x6C, 0x6F, 0x72,
			0x20, 0x2E, 0x32, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x3A, 0x20, 0x33, 0x70, 0x78, 0x20, 0x73, 0x6F,
			0x6C, 0x69, 0x64, 0x20, 0x70, 0x75, 0x72, 0x70, 0x6C, 0x65, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62,
			0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6C, 0x69, 0x6E, 0x65, 0x61, 0x72, 0x2D, 0x67,
			0x72, 0x61, 0x64, 0x69, 0x65, 0x6E, 0x74, 0x28, 0x31, 0x33, 0x35, 0x64, 0x65, 0x67, 0x2C, 0x23, 0x38, 0x62, 0x37, 0x63, 0x66, 0x30, 0x2C, 0x23,
			0x61, 0x34, 0x39, 0x35, 0x66, 0x35, 0x29, 0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x23, 0x31, 0x62, 0x31, 0x62, 0x32, 0x64, 0x3B, 0x66, 0x69,
			0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x31, 0x2E, 0x31, 0x32, 0x29, 0x3B, 0x74, 0x72,
			0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72, 0x6D, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x59, 0x28, 0x2D, 0x31, 0x70, 0x78, 0x29,
			0x3B, 0x62, 0x6F, 0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x30, 0x20, 0x31, 0x34, 0x70, 0x78, 0x20, 0x32, 0x34, 0x70, 0x78, 0x20,
			0x72, 0x67, 0x62, 0x61, 0x28, 0x34, 0x30, 0x2C, 0x35, 0x36, 0x2C, 0x39, 0x34, 0x2C, 0x2E, 0x33, 0x34, 0x29, 0x2C, 0x30, 0x20, 0x36, 0x70, 0x78,
			0x20, 0x31, 0x34, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x34, 0x38, 0x2C, 0x32, 0x30, 0x2C, 0x38, 0x38, 0x2C, 0x2E, 0x33, 0x29, 0x3B,
			0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x7B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72, 0x6D, 0x3A, 0x74,
			0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x59, 0x28, 0x30, 0x29, 0x3B, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67,
			0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x2E, 0x39, 0x34, 0x29, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B,
			0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62, 0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x31, 0x2E, 0x30, 0x36, 0x29, 0x3B,
			0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72, 0x6D, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x59, 0x28, 0x2D, 0x31, 0x70,
			0x78, 0x29, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x61, 0x63, 0x74, 0x69, 0x76, 0x65, 0x7B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x66, 0x6F, 0x72,
			0x6D, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x59, 0x28, 0x30, 0x29, 0x3B, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x3A, 0x62,
			0x72, 0x69, 0x67, 0x68, 0x74, 0x6E, 0x65, 0x73, 0x73, 0x28, 0x2E, 0x39, 0x35, 0x29, 0x3B, 0x7D, 0x2E, 0x62, 0x74, 0x6E, 0x3A, 0x66, 0x6F, 0x63,
			0x75, 0x73, 0x2D, 0x76, 0x69, 0x73, 0x69, 0x62, 0x6C, 0x65, 0x7B, 0x6F, 0x75, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0x3A, 0x33, 0x70, 0x78, 0x20, 0x73,
			0x6F, 0x6C, 0x69, 0x64, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x31, 0x35, 0x35, 0x2C, 0x39, 0x32, 0x2C, 0x32, 0x35, 0x35, 0x2C, 0x2E, 0x36, 0x29,
			0x3B, 0x6F, 0x75, 0x74, 0x6C, 0x69, 0x6E, 0x65, 0x2D, 0x6F, 0x66, 0x66, 0x73, 0x65, 0x74, 0x3A, 0x33, 0x70, 0x78, 0x3B, 0x7D, 0x2E, 0x70, 0x72,
			0x6F, 0x6D, 0x70, 0x74, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x3A, 0x32, 0x34, 0x70, 0x78, 0x20, 0x61, 0x75, 0x74, 0x6F, 0x20, 0x30, 0x20,
			0x61, 0x75, 0x74, 0x6F, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x6D, 0x69, 0x6E, 0x28, 0x39, 0x30, 0x30, 0x70, 0x78,
			0x2C, 0x39, 0x32, 0x76, 0x77, 0x29, 0x3B, 0x6C, 0x69, 0x6E, 0x65, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x2E, 0x37, 0x35, 0x3B,
			0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x6D, 0x69, 0x73, 0x74, 0x79, 0x72, 0x6F, 0x73, 0x65, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D, 0x73, 0x69, 0x7A,
			0x65, 0x3A, 0x63, 0x6C, 0x61, 0x6D, 0x70, 0x28, 0x31, 0x39, 0x70, 0x78, 0x2C, 0x32, 0x2E, 0x31, 0x76, 0x77, 0x2C, 0x32, 0x34, 0x70, 0x78, 0x29,
			0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x77, 0x72, 0x61, 0x70, 0x3A, 0x70, 0x72, 0x65, 0x74, 0x74, 0x79, 0x3B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x69,
			0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x2C, 0x62, 0x61, 0x63,
			0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x2E, 0x33, 0x35, 0x73, 0x20, 0x65, 0x61,
			0x73, 0x65, 0x2C, 0x66, 0x69, 0x6C, 0x74, 0x65, 0x72, 0x20, 0x2E, 0x32, 0x35, 0x73, 0x20, 0x65, 0x61, 0x73, 0x65, 0x3B, 0x7D, 0x66, 0x6F, 0x6F,
			0x74, 0x65, 0x72, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x70, 0x3A, 0x61, 0x75, 0x74, 0x6F, 0x3B, 0x70, 0x61, 0x64, 0x64,
			0x69, 0x6E, 0x67, 0x3A, 0x31, 0x34, 0x70, 0x78, 0x20, 0x31, 0x32, 0x70, 0x78, 0x20, 0x33, 0x30, 0x70, 0x78, 0x20, 0x31, 0x32, 0x70, 0x78, 0x3B,
			0x74, 0x65, 0x78, 0x74, 0x2D, 0x61, 0x6C, 0x69, 0x67, 0x6E, 0x3A, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A,
			0x23, 0x63, 0x62, 0x64, 0x32, 0x65, 0x61, 0x3B, 0x66, 0x6F, 0x6E, 0x74, 0x2D, 0x73, 0x69, 0x7A, 0x65, 0x3A, 0x31, 0x38, 0x70, 0x78, 0x3B, 0x66,
			0x6F, 0x6E, 0x74, 0x2D, 0x77, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x36, 0x30, 0x30, 0x3B, 0x7D, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x20, 0x61,
			0x7B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x23, 0x63, 0x62, 0x64, 0x32, 0x65, 0x61, 0x3B, 0x74, 0x65, 0x78, 0x74, 0x2D, 0x64, 0x65, 0x63, 0x6F,
			0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2D, 0x62, 0x6F, 0x74, 0x74, 0x6F,
			0x6D, 0x3A, 0x31, 0x70, 0x78, 0x20, 0x64, 0x61, 0x73, 0x68, 0x65, 0x64, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x32, 0x30, 0x33, 0x2C, 0x32, 0x31,
			0x30, 0x2C, 0x32, 0x33, 0x34, 0x2C, 0x2E, 0x34, 0x35, 0x29, 0x3B, 0x7D, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x20, 0x61, 0x3A, 0x68, 0x6F, 0x76,
			0x65, 0x72, 0x7B, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x62, 0x75, 0x72, 0x6C, 0x79, 0x77, 0x6F, 0x6F, 0x64, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65,
			0x72, 0x2D, 0x62, 0x6F, 0x74, 0x74, 0x6F, 0x6D, 0x2D, 0x63, 0x6F, 0x6C, 0x6F, 0x72, 0x3A, 0x72, 0x67, 0x62, 0x61, 0x28, 0x32, 0x32, 0x32, 0x2C,
			0x31, 0x38, 0x34, 0x2C, 0x31, 0x33, 0x35, 0x2C, 0x2E, 0x37, 0x29, 0x3B, 0x7D, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x3E, 0x64, 0x69, 0x76, 0x3A,
			0x6C, 0x61, 0x73, 0x74, 0x2D, 0x63, 0x68, 0x69, 0x6C, 0x64, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74, 0x6F, 0x70, 0x3A, 0x32, 0x34,
			0x70, 0x78, 0x3B, 0x7D, 0x2E, 0x62, 0x6F, 0x74, 0x74, 0x6F, 0x6D, 0x2D, 0x73, 0x65, 0x70, 0x7B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x74,
			0x6F, 0x70, 0x3A, 0x35, 0x36, 0x70, 0x78, 0x3B, 0x7D, 0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74,
			0x68, 0x3A, 0x35, 0x32, 0x30, 0x70, 0x78, 0x29, 0x7B, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20, 0x68, 0x31, 0x7B, 0x74, 0x72, 0x61, 0x6E, 0x73,
			0x66, 0x6F, 0x72, 0x6D, 0x3A, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x6C, 0x61, 0x74, 0x65, 0x58, 0x28, 0x2D, 0x35, 0x70, 0x78, 0x29, 0x3B, 0x7D, 0x7D,
			0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x35, 0x32, 0x30, 0x70, 0x78, 0x29, 0x7B,
			0x2E, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x7B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x6A, 0x75,
			0x73, 0x74, 0x69, 0x66, 0x79, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3A, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x7D, 0x2E, 0x62,
			0x74, 0x6E, 0x7B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x69, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x2D, 0x66, 0x6C, 0x65, 0x78, 0x3B, 0x61,
			0x6C, 0x69, 0x67, 0x6E, 0x2D, 0x69, 0x74, 0x65, 0x6D, 0x73, 0x3A, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x6A, 0x75, 0x73, 0x74, 0x69, 0x66,
			0x79, 0x2D, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3A, 0x63, 0x65, 0x6E, 0x74, 0x65, 0x72, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x61,
			0x75, 0x74, 0x6F, 0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x35, 0x34, 0x76, 0x77, 0x3B, 0x70, 0x61, 0x64, 0x64, 0x69,
			0x6E, 0x67, 0x3A, 0x37, 0x70, 0x78, 0x20, 0x31, 0x33, 0x70, 0x78, 0x3B, 0x77, 0x68, 0x69, 0x74, 0x65, 0x2D, 0x73, 0x70, 0x61, 0x63, 0x65, 0x3A,
			0x6E, 0x6F, 0x77, 0x72, 0x61, 0x70, 0x3B, 0x7D, 0x7D, 0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28, 0x70, 0x72, 0x65, 0x66, 0x65, 0x72, 0x73, 0x2D,
			0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x64, 0x2D, 0x6D, 0x6F, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x29, 0x7B, 0x2A,
			0x7B, 0x74, 0x72, 0x61, 0x6E, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x20, 0x21, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74,
			0x61, 0x6E, 0x74, 0x3B, 0x61, 0x6E, 0x69, 0x6D, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x20, 0x21, 0x69, 0x6D, 0x70, 0x6F,
			0x72, 0x74, 0x61, 0x6E, 0x74, 0x3B, 0x7D, 0x7D, 0x2E, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x63, 0x6F,
			0x6C, 0x6F, 0x72, 0x3A, 0x74, 0x68, 0x69, 0x73, 0x74, 0x6C, 0x65, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x69,
			0x6D, 0x61, 0x67, 0x65, 0x3A, 0x6E, 0x6F, 0x6E, 0x65, 0x3B, 0x2D, 0x77, 0x65, 0x62, 0x6B, 0x69, 0x74, 0x2D, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72,
			0x6F, 0x75, 0x6E, 0x64, 0x2D, 0x63, 0x6C, 0x69, 0x70, 0x3A, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67,
			0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x3A, 0x68, 0x6F, 0x76, 0x65, 0x72, 0x7B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x2D, 0x63, 0x6F, 0x6C,
			0x6F, 0x72, 0x3A, 0x79, 0x65, 0x6C, 0x6C, 0x6F, 0x77, 0x3B, 0x62, 0x6F, 0x78, 0x2D, 0x73, 0x68, 0x61, 0x64, 0x6F, 0x77, 0x3A, 0x30, 0x20, 0x30,
			0x20, 0x30, 0x20, 0x31, 0x2E, 0x35, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28, 0x32, 0x35, 0x35, 0x2C, 0x32, 0x31, 0x32, 0x2C, 0x30, 0x2C,
			0x2E, 0x39, 0x35, 0x29, 0x2C, 0x30, 0x20, 0x30, 0x20, 0x33, 0x36, 0x70, 0x78, 0x20, 0x31, 0x34, 0x70, 0x78, 0x20, 0x72, 0x67, 0x62, 0x61, 0x28,
			0x32, 0x35, 0x35, 0x2C, 0x32, 0x31, 0x32, 0x2C, 0x30, 0x2C, 0x2E, 0x36, 0x29, 0x2C, 0x76, 0x61, 0x72, 0x28, 0x2D, 0x2D, 0x73, 0x68, 0x61, 0x64,
			0x6F, 0x77, 0x29, 0x3B, 0x7D, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x20, 0x2E, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x7B, 0x64, 0x69, 0x73,
			0x70, 0x6C, 0x61, 0x79, 0x3A, 0x62, 0x6C, 0x6F, 0x63, 0x6B, 0x3B, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x72, 0x65, 0x6C, 0x61,
			0x74, 0x69, 0x76, 0x65, 0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x31, 0x70, 0x78, 0x3B, 0x62, 0x61, 0x63, 0x6B, 0x67, 0x72, 0x6F, 0x75,
			0x6E, 0x64, 0x3A, 0x70, 0x75, 0x72, 0x70, 0x6C, 0x65, 0x3B, 0x62, 0x6F, 0x72, 0x64, 0x65, 0x72, 0x3A, 0x30, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69,
			0x6E, 0x3A, 0x30, 0x3B, 0x6C, 0x65, 0x66, 0x74, 0x3A, 0x35, 0x30, 0x25, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x63, 0x61, 0x6C, 0x63, 0x28,
			0x31, 0x30, 0x30, 0x76, 0x77, 0x20, 0x2B, 0x20, 0x38, 0x70, 0x78, 0x29, 0x3B, 0x6D, 0x61, 0x72, 0x67, 0x69, 0x6E, 0x2D, 0x6C, 0x65, 0x66, 0x74,
			0x3A, 0x63, 0x61, 0x6C, 0x63, 0x28, 0x2D, 0x35, 0x30, 0x76, 0x77, 0x20, 0x2D, 0x20, 0x34, 0x70, 0x78, 0x29, 0x3B, 0x7D, 0x68, 0x65, 0x61, 0x64,
			0x65, 0x72, 0x20, 0x2E, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x3A, 0x3A, 0x62, 0x65, 0x66, 0x6F, 0x72, 0x65, 0x7B, 0x63, 0x6F, 0x6E, 0x74,
			0x65, 0x6E, 0x74, 0x3A, 0x69, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x3B, 0x64, 0x69, 0x73, 0x70, 0x6C, 0x61, 0x79, 0x3A, 0x6E, 0x6F, 0x6E, 0x65,
			0x3B, 0x7D, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x3A, 0x3A, 0x61, 0x66, 0x74, 0x65, 0x72, 0x7B, 0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3A,
			0x6E, 0x6F, 0x6E, 0x65, 0x20, 0x21, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x61, 0x6E, 0x74, 0x3B, 0x7D, 0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28,
			0x6F, 0x72, 0x69, 0x65, 0x6E, 0x74, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x6C, 0x61, 0x6E, 0x64, 0x73, 0x63, 0x61, 0x70, 0x65, 0x29, 0x20, 0x61,
			0x6E, 0x64, 0x20, 0x28, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x39, 0x30, 0x30, 0x70, 0x78, 0x29, 0x7B, 0x2E, 0x69, 0x6D,
			0x61, 0x67, 0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x7B, 0x6D, 0x61, 0x78, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x36, 0x34, 0x76, 0x77,
			0x3B, 0x6D, 0x61, 0x78, 0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x39, 0x38, 0x64, 0x76, 0x68, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67,
			0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x6D, 0x67, 0x7B, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2D, 0x66, 0x69, 0x74, 0x3A, 0x63,
			0x6F, 0x6E, 0x74, 0x61, 0x69, 0x6E, 0x3B, 0x77, 0x69, 0x64, 0x74, 0x68, 0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74,
			0x3A, 0x31, 0x30, 0x30, 0x25, 0x3B, 0x7D, 0x7D, 0x40, 0x6D, 0x65, 0x64, 0x69, 0x61, 0x28, 0x6D, 0x69, 0x6E, 0x2D, 0x77, 0x69, 0x64, 0x74, 0x68,
			0x3A, 0x39, 0x30, 0x31, 0x70, 0x78, 0x29, 0x7B, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x7B, 0x6D, 0x61, 0x78,
			0x2D, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x3A, 0x37, 0x30, 0x76, 0x68, 0x3B, 0x7D, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66, 0x72, 0x61,
			0x6D, 0x65, 0x20, 0x69, 0x6D, 0x67, 0x7B, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2D, 0x66, 0x69, 0x74, 0x3A, 0x63, 0x6F, 0x76, 0x65, 0x72, 0x3B,
			0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2D, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3A, 0x35, 0x30, 0x25, 0x20, 0x34, 0x30, 0x25, 0x3B,
			0x7D, 0x7D, 0x3C, 0x2F, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x3E, 0x3C, 0x2F, 0x68, 0x65, 0x61, 0x64, 0x3E, 0x3C, 0x62, 0x6F, 0x64, 0x79, 0x3E, 0x3C,
			0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x3E, 0x3C, 0x68, 0x31, 0x3E, 0x49, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x50, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77,
			0x20, 0x26, 0x61, 0x6D, 0x70, 0x3B, 0x20, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6F, 0x6E, 0x3C, 0x2F, 0x68, 0x31, 0x3E, 0x3C,
			0x64, 0x69, 0x76, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x22, 0x20, 0x72, 0x6F, 0x6C, 0x65,
			0x3D, 0x22, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x22, 0x20, 0x61, 0x72, 0x69, 0x61, 0x2D, 0x68, 0x69, 0x64, 0x64, 0x65, 0x6E,
			0x3D, 0x22, 0x74, 0x72, 0x75, 0x65, 0x22, 0x3E, 0x3C, 0x2F, 0x64, 0x69, 0x76, 0x3E, 0x3C, 0x2F, 0x68, 0x65, 0x61, 0x64, 0x65, 0x72, 0x3E, 0x3C,
			0x6D, 0x61, 0x69, 0x6E, 0x3E, 0x3C, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x69, 0x6D, 0x61, 0x67,
			0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x22, 0x3E, 0x3C, 0x61, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x25, 0x25, 0x55, 0x52, 0x4C, 0x25, 
			0x25, 0x22, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x3D, 0x22, 0x5F, 0x62, 0x6C, 0x61, 0x6E, 0x6B, 0x22, 0x20, 0x72, 0x65, 0x6C, 0x3D, 0x22,
			0x6E, 0x6F, 0x6F, 0x70, 0x65, 0x6E, 0x65, 0x72, 0x20, 0x6E, 0x6F, 0x72, 0x65, 0x66, 0x65, 0x72, 0x72, 0x65, 0x72, 0x22, 0x3E, 0x3C, 0x69, 0x6D,
			0x67, 0x20, 0x73, 0x72, 0x63, 0x3D, 0x22, 0x24, 0x7B, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x7D, 0x22, 0x20, 0x61, 0x6C, 0x74, 0x3D, 0x22, 0x69, 0x6D,
			0x67, 0x22, 0x3E, 0x3C, 0x2F, 0x61, 0x3E, 0x3C, 0x2F, 0x66, 0x69, 0x67, 0x75, 0x72, 0x65, 0x3E, 0x3C, 0x64, 0x69, 0x76, 0x20, 0x63, 0x6C, 0x61,
			0x73, 0x73, 0x3D, 0x22, 0x61, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x73, 0x22, 0x3E, 0x3C, 0x62, 0x75, 0x74, 0x74, 0x6F, 0x6E, 0x20, 0x69, 0x64, 0x3D,
			0x22, 0x63, 0x6F, 0x70, 0x79, 0x42, 0x74, 0x6E, 0x22, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x62, 0x74, 0x6E, 0x22, 0x20, 0x74, 0x79,
			0x70, 0x65, 0x3D, 0x22, 0x62, 0x75, 0x74, 0x74, 0x6F, 0x6E, 0x22, 0x20, 0x61, 0x72, 0x69, 0x61, 0x2D, 0x6C, 0x69, 0x76, 0x65, 0x3D, 0x22, 0x70,
			0x6F, 0x6C, 0x69, 0x74, 0x65, 0x22, 0x3E, 0x43, 0x6F, 0x70, 0x79, 0x20, 0x50, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x3C, 0x2F, 0x62, 0x75, 0x74, 0x74,
			0x6F, 0x6E, 0x3E, 0x3C, 0x2F, 0x64, 0x69, 0x76, 0x3E, 0x3C, 0x70, 0x20, 0x69, 0x64, 0x3D, 0x22, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x54, 0x65,
			0x78, 0x74, 0x22, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x22, 0x3E, 0x25, 0x25, 0x50, 0x52, 0x4F,
			0x4D, 0x50, 0x54, 0x25, 0x25, 0x3C, 0x2F, 0x70, 0x3E, 0x3C, 0x2F, 0x6D, 0x61, 0x69, 0x6E, 0x3E, 0x3C, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x3E,
			0x3C, 0x64, 0x69, 0x76, 0x20, 0x63, 0x6C, 0x61, 0x73, 0x73, 0x3D, 0x22, 0x64, 0x69, 0x76, 0x69, 0x64, 0x65, 0x72, 0x20, 0x62, 0x6F, 0x74, 0x74,
			0x6F, 0x6D, 0x2D, 0x73, 0x65, 0x70, 0x22, 0x20, 0x72, 0x6F, 0x6C, 0x65, 0x3D, 0x22, 0x73, 0x65, 0x70, 0x61, 0x72, 0x61, 0x74, 0x6F, 0x72, 0x22,
			0x20, 0x61, 0x72, 0x69, 0x61, 0x2D, 0x68, 0x69, 0x64, 0x64, 0x65, 0x6E, 0x3D, 0x22, 0x74, 0x72, 0x75, 0x65, 0x22, 0x3E, 0x3C, 0x2F, 0x64, 0x69,
			0x76, 0x3E, 0x3C, 0x64, 0x69, 0x76, 0x3E, 0x3C, 0x61, 0x20, 0x68, 0x72, 0x65, 0x66, 0x3D, 0x22, 0x68, 0x74, 0x74, 0x70, 0x73, 0x3A, 0x2F, 0x2F,
			0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x43, 0x6C, 0x65, 0x61, 0x73, 0x62, 0x79, 0x43, 0x6F, 0x64, 0x65, 0x2F, 0x69,
			0x6D, 0x67, 0x70, 0x72, 0x6D, 0x74, 0x22, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x3D, 0x22, 0x5F, 0x62, 0x6C, 0x61, 0x6E, 0x6B, 0x22, 0x20,
			0x72, 0x65, 0x6C, 0x3D, 0x22, 0x6E, 0x6F, 0x6F, 0x70, 0x65, 0x6E, 0x65, 0x72, 0x22, 0x3E, 0x69, 0x6D, 0x67, 0x70, 0x72, 0x6D, 0x74, 0x20, 0x76,
			0x31, 0x2E, 0x32, 0x3C, 0x2F, 0x61, 0x3E, 0x3C, 0x2F, 0x64, 0x69, 0x76, 0x3E, 0x3C, 0x2F, 0x66, 0x6F, 0x6F, 0x74, 0x65, 0x72, 0x3E, 0x60, 0x3B,
			0x28, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x28, 0x29, 0x7B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x62, 0x74, 0x6E, 0x3D, 0x64, 0x6F,
			0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x67, 0x65, 0x74, 0x45, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x42, 0x79, 0x49, 0x64, 0x28, 0x22, 0x63,
			0x6F, 0x70, 0x79, 0x42, 0x74, 0x6E, 0x22, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x74, 0x65, 0x78, 0x74, 0x45, 0x6C, 0x3D, 0x64, 0x6F,
			0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x67, 0x65, 0x74, 0x45, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x42, 0x79, 0x49, 0x64, 0x28, 0x22, 0x70,
			0x72, 0x6F, 0x6D, 0x70, 0x74, 0x54, 0x65, 0x78, 0x74, 0x22, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x6F, 0x72, 0x69, 0x67, 0x69, 0x6E,
			0x61, 0x6C, 0x3D, 0x62, 0x74, 0x6E, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74,
			0x20, 0x69, 0x6D, 0x67, 0x45, 0x6C, 0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x71, 0x75, 0x65, 0x72, 0x79, 0x53, 0x65, 0x6C,
			0x65, 0x63, 0x74, 0x6F, 0x72, 0x28, 0x22, 0x2E, 0x69, 0x6D, 0x61, 0x67, 0x65, 0x2D, 0x66, 0x72, 0x61, 0x6D, 0x65, 0x20, 0x69, 0x6D, 0x67, 0x22,
			0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x28, 0x74, 0x79, 0x70, 0x65, 0x6F, 0x66, 0x20, 0x77, 0x69,
			0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x3D, 0x3D, 0x3D, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x22, 0x26, 0x26, 0x77,
			0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x2E, 0x74, 0x72, 0x69, 0x6D, 0x28, 0x29, 0x29, 0x3F, 0x77, 0x69, 0x6E, 0x64,
			0x6F, 0x77, 0x2E, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x2E, 0x74, 0x72, 0x69, 0x6D, 0x28, 0x29, 0x3A, 0x6E, 0x65, 0x77, 0x20, 0x55, 0x52, 0x4C, 0x53,
			0x65, 0x61, 0x72, 0x63, 0x68, 0x50, 0x61, 0x72, 0x61, 0x6D, 0x73, 0x28, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2E, 0x73, 0x65, 0x61,
			0x72, 0x63, 0x68, 0x29, 0x2E, 0x67, 0x65, 0x74, 0x28, 0x22, 0x69, 0x6D, 0x67, 0x22, 0x29, 0x3B, 0x69, 0x66, 0x28, 0x66, 0x6E, 0x61, 0x6D, 0x65,
			0x29, 0x7B, 0x69, 0x6D, 0x67, 0x45, 0x6C, 0x2E, 0x73, 0x72, 0x63, 0x3D, 0x66, 0x6E, 0x61, 0x6D, 0x65, 0x3B, 0x7D, 0x61, 0x73, 0x79, 0x6E, 0x63,
			0x20, 0x66, 0x75, 0x6E, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x63, 0x6F, 0x70, 0x79, 0x54, 0x6F, 0x43, 0x6C, 0x69, 0x70, 0x62, 0x6F, 0x61, 0x72,
			0x64, 0x28, 0x74, 0x65, 0x78, 0x74, 0x29, 0x7B, 0x74, 0x72, 0x79, 0x7B, 0x69, 0x66, 0x28, 0x6E, 0x61, 0x76, 0x69, 0x67, 0x61, 0x74, 0x6F, 0x72,
			0x2E, 0x63, 0x6C, 0x69, 0x70, 0x62, 0x6F, 0x61, 0x72, 0x64, 0x26, 0x26, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x69, 0x73, 0x53, 0x65, 0x63,
			0x75, 0x72, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x78, 0x74, 0x29, 0x7B, 0x61, 0x77, 0x61, 0x69, 0x74, 0x20, 0x6E, 0x61, 0x76, 0x69, 0x67, 0x61,
			0x74, 0x6F, 0x72, 0x2E, 0x63, 0x6C, 0x69, 0x70, 0x62, 0x6F, 0x61, 0x72, 0x64, 0x2E, 0x77, 0x72, 0x69, 0x74, 0x65, 0x54, 0x65, 0x78, 0x74, 0x28,
			0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x72, 0x75, 0x65, 0x3B, 0x7D, 0x7D, 0x63, 0x61, 0x74, 0x63,
			0x68, 0x28, 0x65, 0x29, 0x7B, 0x7D, 0x74, 0x72, 0x79, 0x7B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x74, 0x61, 0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D,
			0x65, 0x6E, 0x74, 0x2E, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x28, 0x22, 0x74, 0x65, 0x78, 0x74, 0x61,
			0x72, 0x65, 0x61, 0x22, 0x29, 0x3B, 0x74, 0x61, 0x2E, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x3D, 0x74, 0x65, 0x78, 0x74, 0x3B, 0x74, 0x61, 0x2E, 0x73,
			0x65, 0x74, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x28, 0x22, 0x72, 0x65, 0x61, 0x64, 0x6F, 0x6E, 0x6C, 0x79, 0x22, 0x2C, 0x22,
			0x22, 0x29, 0x3B, 0x74, 0x61, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3D, 0x22, 0x66, 0x69,
			0x78, 0x65, 0x64, 0x22, 0x3B, 0x74, 0x61, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x74, 0x6F, 0x70, 0x3D, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22,
			0x3B, 0x74, 0x61, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x6C, 0x65, 0x66, 0x74, 0x3D, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22, 0x3B, 0x74, 0x61,
			0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x6F, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x3D, 0x22, 0x30, 0x22, 0x3B, 0x64, 0x6F, 0x63, 0x75, 0x6D,
			0x65, 0x6E, 0x74, 0x2E, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x43, 0x68, 0x69, 0x6C, 0x64, 0x28, 0x74, 0x61, 0x29,
			0x3B, 0x74, 0x61, 0x2E, 0x66, 0x6F, 0x63, 0x75, 0x73, 0x28, 0x29, 0x3B, 0x74, 0x61, 0x2E, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x28, 0x29, 0x3B,
			0x74, 0x61, 0x2E, 0x73, 0x65, 0x74, 0x53, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x52, 0x61, 0x6E, 0x67, 0x65, 0x28, 0x30, 0x2C, 0x74,
			0x61, 0x2E, 0x76, 0x61, 0x6C, 0x75, 0x65, 0x2E, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x6F, 0x6B,
			0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x65, 0x78, 0x65, 0x63, 0x43, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x28, 0x22, 0x63,
			0x6F, 0x70, 0x79, 0x22, 0x29, 0x3B, 0x74, 0x61, 0x2E, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x28, 0x29, 0x3B, 0x69, 0x66, 0x28, 0x6F, 0x6B, 0x29,
			0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x72, 0x75, 0x65, 0x3B, 0x7D, 0x63, 0x61, 0x74, 0x63, 0x68, 0x28, 0x65, 0x29, 0x7B, 0x7D, 0x74,
			0x72, 0x79, 0x7B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x73, 0x70, 0x61, 0x6E, 0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x63,
			0x72, 0x65, 0x61, 0x74, 0x65, 0x45, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x28, 0x22, 0x73, 0x70, 0x61, 0x6E, 0x22, 0x29, 0x3B, 0x73, 0x70, 0x61,
			0x6E, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x74, 0x65, 0x78, 0x74, 0x3B, 0x73, 0x70, 0x61, 0x6E, 0x2E,
			0x63, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x45, 0x64, 0x69, 0x74, 0x61, 0x62, 0x6C, 0x65, 0x3D, 0x22, 0x74, 0x72, 0x75, 0x65, 0x22, 0x3B, 0x73,
			0x70, 0x61, 0x6E, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x70, 0x6F, 0x73, 0x69, 0x74, 0x69, 0x6F, 0x6E, 0x3D, 0x22, 0x66, 0x69, 0x78, 0x65,
			0x64, 0x22, 0x3B, 0x73, 0x70, 0x61, 0x6E, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x74, 0x6F, 0x70, 0x3D, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22,
			0x3B, 0x73, 0x70, 0x61, 0x6E, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x6C, 0x65, 0x66, 0x74, 0x3D, 0x22, 0x31, 0x30, 0x70, 0x78, 0x22, 0x3B,
			0x73, 0x70, 0x61, 0x6E, 0x2E, 0x73, 0x74, 0x79, 0x6C, 0x65, 0x2E, 0x6F, 0x70, 0x61, 0x63, 0x69, 0x74, 0x79, 0x20, 0x3D, 0x22, 0x30, 0x22, 0x3B,
			0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x62, 0x6F, 0x64, 0x79, 0x2E, 0x61, 0x70, 0x70, 0x65, 0x6E, 0x64, 0x43, 0x68, 0x69, 0x6C,
			0x64, 0x28, 0x73, 0x70, 0x61, 0x6E, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x72, 0x61, 0x6E, 0x67, 0x65, 0x3D, 0x64, 0x6F, 0x63, 0x75,
			0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x52, 0x61, 0x6E, 0x67, 0x65, 0x28, 0x29, 0x3B, 0x72, 0x61, 0x6E, 0x67, 0x65,
			0x2E, 0x73, 0x65, 0x6C, 0x65, 0x63, 0x74, 0x4E, 0x6F, 0x64, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x73, 0x28, 0x73, 0x70, 0x61, 0x6E,
			0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x73, 0x65, 0x6C, 0x3D, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E, 0x67, 0x65, 0x74, 0x53, 0x65,
			0x6C, 0x65, 0x63, 0x74, 0x69, 0x6F, 0x6E, 0x28, 0x29, 0x3B, 0x73, 0x65, 0x6C, 0x2E, 0x72, 0x65, 0x6D, 0x6F, 0x76, 0x65, 0x41, 0x6C, 0x6C, 0x52,
			0x61, 0x6E, 0x67, 0x65, 0x73, 0x28, 0x29, 0x3B, 0x73, 0x65, 0x6C, 0x2E, 0x61, 0x64, 0x64, 0x52, 0x61, 0x6E, 0x67, 0x65, 0x28, 0x72, 0x61, 0x6E,
			0x67, 0x65, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x6F, 0x6B, 0x32, 0x3D, 0x64, 0x6F, 0x63, 0x75, 0x6D, 0x65, 0x6E, 0x74, 0x2E, 0x65,
			0x78, 0x65, 0x63, 0x43, 0x6F, 0x6D, 0x6D, 0x61, 0x6E, 0x64, 0x28, 0x22, 0x63, 0x6F, 0x70, 0x79, 0x22, 0x29, 0x3B, 0x73, 0x65, 0x6C, 0x2E, 0x72,
			0x65, 0x6D, 0x6F, 0x76, 0x65, 0x41, 0x6C, 0x6C, 0x52, 0x61, 0x6E, 0x67, 0x65, 0x73, 0x28, 0x29, 0x3B, 0x73, 0x70, 0x61, 0x6E, 0x2E, 0x72, 0x65,
			0x6D, 0x6F, 0x76, 0x65, 0x28, 0x29, 0x3B, 0x69, 0x66, 0x28, 0x6F, 0x6B, 0x32, 0x29, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E, 0x20, 0x74, 0x72, 0x75,
			0x65, 0x3B, 0x7D, 0x63, 0x61, 0x74, 0x63, 0x68, 0x28, 0x65, 0x29, 0x7B, 0x7D, 0x74, 0x72, 0x79, 0x7B, 0x77, 0x69, 0x6E, 0x64, 0x6F, 0x77, 0x2E,
			0x70, 0x72, 0x6F, 0x6D, 0x70, 0x74, 0x28, 0x22, 0x43, 0x6F, 0x70, 0x79, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x74, 0x65, 0x78, 0x74, 0x3A, 0x22,
			0x2C, 0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x7D, 0x63, 0x61, 0x74, 0x63, 0x68, 0x28, 0x5F, 0x29, 0x7B, 0x7D, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6E,
			0x20, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x3B, 0x7D, 0x62, 0x74, 0x6E, 0x2E, 0x61, 0x64, 0x64, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4C, 0x69, 0x73, 0x74,
			0x65, 0x6E, 0x65, 0x72, 0x28, 0x22, 0x63, 0x6C, 0x69, 0x63, 0x6B, 0x22, 0x2C, 0x61, 0x73, 0x79, 0x6E, 0x63, 0x28, 0x29, 0x3D, 0x3E, 0x7B, 0x63,
			0x6F, 0x6E, 0x73, 0x74, 0x20, 0x74, 0x65, 0x78, 0x74, 0x3D, 0x74, 0x65, 0x78, 0x74, 0x45, 0x6C, 0x2E, 0x69, 0x6E, 0x6E, 0x65, 0x72, 0x54, 0x65,
			0x78, 0x74, 0x2E, 0x74, 0x72, 0x69, 0x6D, 0x28, 0x29, 0x3B, 0x63, 0x6F, 0x6E, 0x73, 0x74, 0x20, 0x6F, 0x6B, 0x3D, 0x61, 0x77, 0x61, 0x69, 0x74,
			0x20, 0x63, 0x6F, 0x70, 0x79, 0x54, 0x6F, 0x43, 0x6C, 0x69, 0x70, 0x62, 0x6F, 0x61, 0x72, 0x64, 0x28, 0x74, 0x65, 0x78, 0x74, 0x29, 0x3B, 0x62,
			0x74, 0x6E, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x6F, 0x6B, 0x3F, 0x22, 0x43, 0x6F, 0x70, 0x69, 0x65,
			0x64, 0x21, 0x22, 0x3A, 0x22, 0x43, 0x6F, 0x70, 0x79, 0x20, 0x66, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x22, 0x3B, 0x62, 0x74, 0x6E, 0x2E, 0x64, 0x69,
			0x73, 0x61, 0x62, 0x6C, 0x65, 0x64, 0x3D, 0x74, 0x72, 0x75, 0x65, 0x3B, 0x73, 0x65, 0x74, 0x54, 0x69, 0x6D, 0x65, 0x6F, 0x75, 0x74, 0x28, 0x28, 
			0x29, 0x3D, 0x3E, 0x7B, 0x62, 0x74, 0x6E, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x43, 0x6F, 0x6E, 0x74, 0x65, 0x6E, 0x74, 0x3D, 0x6F, 0x72, 0x69, 0x67,
			0x69, 0x6E, 0x61, 0x6C, 0x3B, 0x62, 0x74, 0x6E, 0x2E, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6C, 0x65, 0x64, 0x3D, 0x66, 0x61, 0x6C, 0x73, 0x65, 0x3B,
			0x7D, 0x2C, 0x31, 0x36, 0x30, 0x30, 0x29, 0x3B, 0x7D, 0x29, 0x3B, 0x20, 0x7D, 0x29, 0x28, 0x29, 0x7D, 0x29, 0x3B, 0x3C, 0x2F, 0x73, 0x63, 0x72,
			0x69, 0x70, 0x74, 0x3E, 0x3C, 0x2F, 0x62, 0x6F, 0x64, 0x79, 0x3E, 0x3C, 0x2F, 0x68, 0x74, 0x6D, 0x6C, 0x3E, 0x3C, 0x73, 0x63, 0x72, 0x69, 0x70,
			0x74, 0x3E, 0x3C, 0x2F, 0x62, 0x6F, 0x64, 0x79, 0x3E, 0x3C, 0x2F, 0x68, 0x74, 0x6D, 0x6C, 0x3E
		};
		
		// For X-Twitter, Mastodon, Tumblr & Flickr.
		constexpr uint8_t
			PROFILE_VEC_INTERNAL_DIFF 		= 38,	// Bytes we don't count as part of internal profile size.
			PROFILE_VEC_MAIN_DIFF 	 		= 22,	// Bytes we don't count as part of profile size.
			PROFILE_VEC_INSERT_INDEX 		= 0x14, // Insert location within segment_vec for the color profile (profile_vec).
			PROFILE_VEC_SIZE_FIELD_INDEX 	= 0x28, // Start index location for internal size field of the image color profile.(Max four bytes, only two used).
			SEGMENT_VEC_SIZE_FIELD_INDEX 	= 0x16; // Start index location for size field of the main color profile. (Max two bytes).
		
		uint8_t bits = 16;
		
		if (args.option == Option::None) { 
			segment_vec.insert(segment_vec.begin() + PROFILE_VEC_INSERT_INDEX, profile_vec.begin(), profile_vec.end());
		} else {
			constexpr uint16_t
				BLUESKY_VEC_HEIGHT_INDEX = 0x10D,
				BLUESKY_VEC_WIDTH_INDEX  = 0x101;
				
			update_value(bluesky_vec, BLUESKY_VEC_HEIGHT_INDEX, height, bits);
			update_value(bluesky_vec, BLUESKY_VEC_WIDTH_INDEX, width, bits);
			
			constexpr uint8_t	
				SEGMENT_VEC_INSERT_INDEX = 0xE3,
				SEGMENT_VEC_START_INDEX =  0x17;
				
			bluesky_vec.insert(bluesky_vec.begin() + SEGMENT_VEC_INSERT_INDEX, segment_vec.begin() + SEGMENT_VEC_START_INDEX, segment_vec.end());
			segment_vec.swap(bluesky_vec);
		}

		// Clear vectors.
		std::vector<uint8_t>().swap(bluesky_vec);
		std::vector<uint8_t>().swap(profile_vec);
		
		constexpr std::array<uint8_t, 10> PROMPT_INSERT_MARKER	{'%','%','P','R','O','M','P','T','%','%'};
		constexpr std::array<uint8_t, 7>  URL_INSERT_MARKER		{'%','%','U','R','L','%','%'};
		
		auto prompt_pos = searchSig(segment_vec, std::span(PROMPT_INSERT_MARKER));
		auto url_pos 	= searchSig(segment_vec, std::span(URL_INSERT_MARKER));

		segment_vec.insert(segment_vec.begin() + *prompt_pos, utf8_prompt.begin(), utf8_prompt.end());
		segment_vec.erase(segment_vec.begin() + *prompt_pos + utf8_prompt.size(), segment_vec.begin() + *prompt_pos + utf8_prompt.size() + PROMPT_INSERT_MARKER.size());
		
		segment_vec.insert(segment_vec.begin() + *url_pos, utf8_url.begin(), utf8_url.end());
		segment_vec.erase(segment_vec.begin() + *url_pos + utf8_url.size(), segment_vec.begin() + *url_pos + utf8_url.size() + URL_INSERT_MARKER.size());
		
		std::string().swap(utf8_prompt);
		std::string().swap(utf8_url);
		
		constexpr uint16_t 
			MAX_SEGMENT_SIZE 		= 65534,     // ~64KB
			TWITTER_SEGMENT_LIMIT	= 10 * 1024; // X-Twitter 10KB.
		
		uint32_t segment_size = static_cast<uint32_t>(segment_vec.size());
		
		if (args.option == Option::None && segment_size > TWITTER_SEGMENT_LIMIT) {
			std::wcerr << "\n\nWarning: Data content exceeds the maximum segment size limit for X-Twitter.\n\t Image will not be compatible for posting on that platform.\n";
		}
		
		if (segment_size > MAX_SEGMENT_SIZE) {
			throw std::runtime_error("File Size Error: Data content size exceeds the maximum segment limit.");
		}
		
		#ifdef _WIN32
			if (old_stdin_mode  != -1) (void)_setmode(_fileno(stdin),  old_stdin_mode);
    		if (old_stdout_mode != -1) (void)_setmode(_fileno(stdout), old_stdout_mode);		
		#endif
	
		if (args.option == Option::Bluesky) {
			segment_size -= 4; // For Bluesky segment size, don't count the JPG ID + APP ID "FFD8FFE1" (4 bytes).
		
			constexpr uint8_t 
				EXIF_SIZE_FIELD_INDEX 			= 0x04,  
				EXIF_XRES_OFFSET_FIELD_INDEX 	= 0x2A,  
				EXIF_YRES_OFFSET_FIELD_INDEX 	= 0x36,  
				EXIF_ARTIST_SIZE_FIELD_INDEX 	= 0x4A,  
				EXIF_SUBIFD_OFFSET_FIELD_INDEX 	= 0x5A;  

			const uint16_t	
				EXIF_XRES_OFFSET   = segment_size - 0x36,
				EXIF_YRES_OFFSET   = segment_size - 0x2E,
				EXIF_SUBIFD_OFFSET = segment_size - 0x26,
				EXIF_ARTIST_SIZE   = segment_size - 0x8C;
				
			update_value(segment_vec, EXIF_SIZE_FIELD_INDEX , segment_size, bits);
		
			bits = 32;

			update_value(segment_vec, EXIF_XRES_OFFSET_FIELD_INDEX, EXIF_XRES_OFFSET, bits);
			update_value(segment_vec, EXIF_YRES_OFFSET_FIELD_INDEX, EXIF_YRES_OFFSET, bits);
			update_value(segment_vec, EXIF_ARTIST_SIZE_FIELD_INDEX, EXIF_ARTIST_SIZE, bits); 
			update_value(segment_vec, EXIF_SUBIFD_OFFSET_FIELD_INDEX, EXIF_SUBIFD_OFFSET, bits);
		} else {
			// Update color profile segment size field (FFE2xxxx)
			update_value(segment_vec, SEGMENT_VEC_SIZE_FIELD_INDEX, segment_size - PROFILE_VEC_MAIN_DIFF, bits);

			// Update internal color profile size field
			update_value(segment_vec, PROFILE_VEC_SIZE_FIELD_INDEX, segment_size - PROFILE_VEC_INTERNAL_DIFF, bits);
		}	

		image_file_vec.insert(image_file_vec.begin(), segment_vec.begin(), segment_vec.end());
		std::vector<uint8_t>().swap(segment_vec); // Clear

		image_file_size = static_cast<uint32_t>(image_file_vec.size());

		std::random_device rd;
    	std::mt19937 gen(rd());
    	std::uniform_int_distribution<> dist(10000, 99999);
	
		const std::string OUTPUT_FILENAME = "imgprmt_" + std::to_string(dist(gen)) + ".jpg";

		std::ofstream write_file_fs(OUTPUT_FILENAME, std::ios::binary);
		if (!write_file_fs) {
			throw std::runtime_error("Write Error: Unable to write to file. Make sure you have WRITE permissions for this location.");
		}

		write_file_fs.write(reinterpret_cast<const char*>(image_file_vec.data()), image_file_size);
		
		std::vector<uint8_t>().swap(image_file_vec);
		std::cout << "\nSaved \"prompt-embedded\" JPG image: " << OUTPUT_FILENAME << " (" << image_file_size << " bytes).\n\n";
		return 0;
	}
	catch (const std::runtime_error& e) {
    	std::cerr << "\n" << e.what() << "\n\n";
    	return 1;
    }
}
